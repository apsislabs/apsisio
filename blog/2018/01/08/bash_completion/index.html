<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>Blog: Save Time with Bash Programmable Autocompletion | Apsis Labs</title><meta name="description" content="&lt;p&gt;Every developer should have at least a basic mastery of their command line. I&amp;#39;d argue
that part of that mastery is to develop a set of customizations they take with them
wherever they go. These customizations should make things you do all the time faster.
Obviously there are diminshing returns here[^2].&lt;/p&gt;
&lt;p&gt;Some of my customizations include bash aliases for my most used git commands&lt;/p&gt;
"/><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"/><link rel="manifest" href="/site.webmanifest"/><meta name="description" content="&lt;p&gt;Every developer should have at least a basic mastery of their command line. I&amp;#39;d argue
that part of that mastery is to develop a set of customizations they take with them
wherever they go. These customizations should make things you do all the time faster.
Obviously there are diminshing returns here[^2].&lt;/p&gt;
&lt;p&gt;Some of my customizations include bash aliases for my most used git commands&lt;/p&gt;
"/><meta property="og:url" content="https://apsis.io"/><meta property="og:type" content="website"/><meta property="og:title" content="Blog: Save Time with Bash Programmable Autocompletion"/><meta property="og:description" content="&lt;p&gt;Every developer should have at least a basic mastery of their command line. I&amp;#39;d argue
that part of that mastery is to develop a set of customizations they take with them
wherever they go. These customizations should make things you do all the time faster.
Obviously there are diminshing returns here[^2].&lt;/p&gt;
&lt;p&gt;Some of my customizations include bash aliases for my most used git commands&lt;/p&gt;
"/><meta property="og:image" content="https://apsis.io/social.png"/><meta name="twitter:card" content="summary_large_image"/><meta property="twitter:domain" content="apsis.io"/><meta property="twitter:url" content="https://apsis.io"/><meta name="twitter:title" content="Blog: Save Time with Bash Programmable Autocompletion"/><meta name="twitter:description" content="&lt;p&gt;Every developer should have at least a basic mastery of their command line. I&amp;#39;d argue
that part of that mastery is to develop a set of customizations they take with them
wherever they go. These customizations should make things you do all the time faster.
Obviously there are diminshing returns here[^2].&lt;/p&gt;
&lt;p&gt;Some of my customizations include bash aliases for my most used git commands&lt;/p&gt;
"/><meta name="twitter:image" content="https://apsis.io/social.png"/><meta name="next-head-count" content="3"/><link rel="preload" href="/_next/static/media/a34f9d1faa5f3315-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/_next/static/media/a9387c470a117487-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/_next/static/media/37e85b36581a02ab-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/_next/static/media/3478b6abef19b3b3-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/_next/static/media/035951aefad7b653-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/_next/static/css/eb18153a0a375343.css" as="style"/><link rel="stylesheet" href="/_next/static/css/eb18153a0a375343.css" data-n-g=""/><link rel="preload" href="/_next/static/css/01bbc1cf78aab92b.css" as="style"/><link rel="stylesheet" href="/_next/static/css/01bbc1cf78aab92b.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-42372ed130431b0a.js"></script><script src="/_next/static/chunks/webpack-38cee4c0e358b1a3.js" defer=""></script><script src="/_next/static/chunks/framework-64ad27b21261a9ce.js" defer=""></script><script src="/_next/static/chunks/main-58eb4e77e43e295f.js" defer=""></script><script src="/_next/static/chunks/pages/_app-2003168507d95f21.js" defer=""></script><script src="/_next/static/chunks/25-c9e36e11cdefe32e.js" defer=""></script><script src="/_next/static/chunks/444-fdf54067393e057a.js" defer=""></script><script src="/_next/static/chunks/pages/blog/%5Byear%5D/%5Bmonth%5D/%5Bday%5D/%5Bslug%5D-97e1c6e54593dd15.js" defer=""></script><script src="/_next/static/B7QLQHINFLJsMXi5mwaz5/_buildManifest.js" defer=""></script><script src="/_next/static/B7QLQHINFLJsMXi5mwaz5/_ssgManifest.js" defer=""></script><style id="__jsx-1589735335">:root{--font-inter:'__Inter_d65c78', '__Inter_Fallback_d65c78';--font-mono:'__IBM_Plex_Mono_191acc', '__IBM_Plex_Mono_Fallback_191acc'}</style></head><body><div id="__next"><section class="Section_section__rDOJq Section_section--bordered__v_Az0"><div class="Section_section__mask__iGDmr"></div><div class="Section_section__container__9Fwqr"><div class="Section_section__content__Klb0i"><nav class="Navbar_navbar__pYr0W"><a class="Navbar_navbar__logo__NNGhf" href="/"><h1 class="LogoType_logotype__iHLMP"><svg viewBox="0 0 64 64" fill="none" xmlns="http://www.w3.org/2000/svg" class="LogoType_logotype__planet__674Ub" width="24" height="24"><path fill-rule="evenodd" clip-rule="evenodd" d="M32 64C49.6731 64 64 49.6731 64 32C64 14.3269 49.6731 0 32 0C14.3269 0 0 14.3269 0 32C0 49.6731 14.3269 64 32 64ZM32 61C48.0163 61 61 48.0163 61 32C61 15.9837 48.0163 3 32 3C15.9837 3 3 15.9837 3 32C3 48.0163 15.9837 61 32 61ZM58 32C58 46.3594 46.3594 58 32 58C17.6406 58 6 46.3594 6 32C6 17.6406 17.6406 6 32 6C46.3594 6 58 17.6406 58 32ZM44 26C47.3137 26 50 23.3137 50 20C50 16.6863 47.3137 14 44 14C40.6863 14 38 16.6863 38 20C38 23.3137 40.6863 26 44 26Z" fill="currentColor"></path></svg>Apsis Labs</h1></a><nav class="Navbar_navbar__nav__YFZzV"><a class="Navbar_navbar__nav_item__OpfdQ" href="/">Home</a><a class="Navbar_navbar__nav_item__OpfdQ" href="/blog/">Blog</a></nav></nav></div></div></section><section class="Section_section__rDOJq Section_section--spaced__Ihmp2 Section_section--narrow__GIboH"><div class="Section_section__mask__iGDmr"></div><div class="Section_section__container__9Fwqr"><div class="Section_section__content__Klb0i"><div class="Post_post-wrapper__s850H"><article class="Post_post__m_Xor" itemType="http://schema.org/BlogPosting"><header class="Post_post__header__pEZ4C"><div><h1 class="Post_post__title__eUeKR"><a href="/blog/2018/01/08/bash_completion/">Save Time with Bash Programmable Autocompletion</a></h1><footer class="Post_post__meta__j55Gy">Posted on<!-- --> <time dateTime="2018-01-08" itemProp="datePublished">2018-01-08</time> <!-- -->by<!-- --> <span itemProp="author" itemscope="" itemType="http://schema.org/Person"><span itemProp="name">chris</span></span></footer></div><div class="Post_post__image-wrapper__mjNlP"><img src="/img/posts/bash.gif" alt="Save Time with Bash Programmable Autocompletion" class="Post_post__image__Dbjks" data-action="zoom"/></div></header><div class="Post_post__content__SHRW1"><p>Every developer should have at least a basic mastery of their command line. I&#39;d argue
that part of that mastery is to develop a set of customizations they take with them
wherever they go. These customizations should make things you do all the time faster.
Obviously there are diminshing returns here<sup><a id="footnote-ref-2" href="#footnote-2" data-footnote-ref aria-describedby="footnote-label">1</a></sup>.</p>
<p>Some of my customizations include bash aliases for my most used git commands. <code>ga</code> is
short for <code>git add</code>, <code>gap</code> is short for <code>git add -p</code>, etc. I also like to have a
syntax highlighted <code>cat</code> and <code>less</code> available to me using <a href="http://pygments.org/">Pygments</a>.</p>
<p>Today I added something I&#39;ve wanted for a long time: a <code>cd</code> that works relative to
the directory I do most of my development work in. Now I can run <code>cdx subdir_of_x</code>
and it will take me to <code>~/x/subdir_of_x</code>.</p>
<p>You may be wondering &quot;Why use precious kilobytes of storage and hours of time writing
this up!?&quot; And you&#39;d be corect. By itself, this is not worthy of a blog post.
I, however, also added autocompletion for the contents of that directory, and <em>that</em>
is worth writing about.</p>
<p>What follows is a short tutorial on bash autocompletion and a tiny bit of bash programming
information. It assumes you have a working knowledge of programming, and at least passing
familiarity with your terminal.</p>
<h2>The Function</h2>
<p>In and of itself, this a very easy function<sup><a id="footnote-ref-1" href="#footnote-1" data-footnote-ref aria-describedby="footnote-label">2</a></sup> to write. In your <code>~/.bashrc</code> add:</p>
<pre><code>function cdx {
    cd &quot;$HOME/x/$1&quot;
}
</code></pre><p>My first test looked like this:</p>
<pre><code>cdx my_code  &lt;TAB&gt;  _base
</code></pre><p>No autocomplete, just big gaping tabs in the middle of my command. What&#39;s an enterprising
developer<sup><a id="footnote-ref-4" href="#footnote-4" data-footnote-ref aria-describedby="footnote-label">3</a></sup> to do? Spend the morning figuring it out, of course.</p>
<h2>The Code</h2>
<p>First, the good stuff. All together, when placed in your <code>~/.bashrc</code> and <code>source</code>ed,
the following works for hypothetical directory <code>x</code> in your home directory using the new
command <code>cdx</code>:</p>
<pre><code>function cdx {
    cd &quot;$HOME/x/$1&quot;
}
function _cdx {
    local cur opts

    opts=&quot;$(ls -1 ~/x)&quot;
    cur=&quot;${COMP_WORDS[COMP_CWORD]}&quot;

    COMPREPLY=( $(compgen -W &quot;${opts}&quot; -- ${cur}) )
    return 0
}
complete -F _cdx cdx
</code></pre><p>To make it work:</p>
<ol>
<li>Insert this in <code>~/.bashrc</code>.</li>
<li>Replace all instances of &quot;x&quot; with a directory from your <code>$HOME</code> directory.</li>
<li>Call <code>source ~/.bashrc</code>.</li>
</ol>
<p>You may want to rename <code>cdx</code> with a more intuitive name (for Apsis code, for example,
I&#39;d use <code>cda</code> and <code>_cda</code>).</p>
<h2>The Explanation</h2>
<p>Now to break the <code>_cdx</code> function down. When it gets obvious feel free to skip to the end, I&#39;ve
attempted to order this from most specific to broadest bash knowledge. (In order of <em>my</em> current
knowledge of bash). I&#39;ve left the most basic stuff (like explaining <code>ls</code>) out.</p>
<ol>
<li><p><code>complete -F _cdx cdx</code> is how you let bash know to attempt an autocomplete. In English it&#39;s:</p>
<blockquote>
<p>When I run the cdx command please use the function _cdx to autocomplete the command.</p>
</blockquote>
</li>
<li><p><code>compgen -W &quot;${opts}&quot; -- ${cur}</code> is the function that searches an array of possibilities (<code>-W</code>)
for the text after <code>--</code>. It&#39;s pretty rigid: no fuzzy searching, no autocorrecting. It just returns
&quot;things from the array that start with what you typed.&quot; You are free to replace it with
whatever you want as long as it too returns an array (space separated string) of the options.
In English:</p>
<blockquote>
<p>Please give me all the words in the string &#39;opts&#39; that start with what&#39;s in &#39;cur&#39;.</p>
</blockquote>
</li>
<li><p><code>COMPREPLY</code> is basically the return value of this function. Whatever array you return here will be
presented to you on the command line as options for autocompletion. In English:</p>
<blockquote>
<p>Here&#39;s what I want to pick from when autocompleting with the current inputs.</p>
</blockquote>
</li>
<li><p><code>cur=&quot;${COMP_WORDS[COMP_CWORD]}&quot;</code> is setting <code>cur</code> to the last word on the command line. <code>COMP_WORDS</code>
and <code>COMP_CWORD</code> are the inputs to this function. (You can actually make them real bash function
parameters if you want to, but they&#39;re already acceptably named). They are special bash variables
that are only available in completion functions. <code>COMP_WORDS</code> is the array of strings currently
entered on the command line. <code>COMP_CWORDS</code> is the current length of the <code>COMP_WORDS</code> array. In English:</p>
<blockquote>
<p>Set the variable &#39;cur&#39; to the last word on the command line.</p>
</blockquote>
</li>
<li><p><code>opts=&quot;$(ls -1 ~/x)&quot;</code> is where we set the available options by creating an array (space separated string)
from the output of <code>ls -1 ~/x</code>. This gets used in the <code>compgen</code> command. In English:</p>
<blockquote>
<p>Set &quot;opts&quot; to the output of &quot;ls -1 ~/x&quot; as the list of potential options to autocomplete from.</p>
</blockquote>
</li>
<li><p><code>local cur opts</code> is a declaration of the cur and opts variables. By using <code>local</code> we avoid cluttering
the global variable namespace. In English:</p>
<blockquote>
<p>I&#39;m going to use the cur and opts variables. You can forget them when this function ends.</p>
</blockquote>
</li>
<li><p><code>return 0</code> quits the function and sets the bash exit code. <code>0</code> is success, all other values are failures.
This is useful in other bash scripts when you want to use it with <code>&amp;&amp;</code> <code>||</code>. Here it simply informs bash
that the completion script was successful. In English:</p>
<blockquote>
<p>IT WORKED! Show the user the values in &quot;COMPREPLY&quot;!</p>
</blockquote>
</li>
</ol>
<h2>Improvements</h2>
<p>This is a great start, and super useful as is, but there is more that could be done:</p>
<ol>
<li><p>Going deeper: it&#39;d be nice if I could keep autocompleting deeper into the directory, so <code>cdx ydir/zdi</code>
could autocomplete to <code>~/x/ydir/zdir</code>. This would involve making the <code>opts=</code> line more intelligent.</p>
</li>
<li><p>Fuzzy searching: I am great at typos. It&#39;d be nice if I could replace <code>compgen</code> with something more
intelligent that will ignore small typos.</p>
</li>
<li><p>More generic: Being able to match <code>cda</code> or <code>cdb</code> to switch to subdirectories of <code>~/apsis</code> or <code>~/bread</code>
would be nice. Writing a script to handle the unique cases when bash fires up would be easily doable.
It would, however, require separate autocomplete functions for each named function becuase <code>complete</code>
only accepts literal command names.</p>
</li>
</ol>
<h2>Troubleshooting/Further Reading</h2>
<p>If the above doesn&#39;t work it&#39;s possible your <code>progcomp</code> bash option isn&#39;t set. You can check with:</p>
<p><code>echo $BASHOPTS | grep -q progcomp &amp;&amp; echo &quot;YES&quot; || echo &quot;NO&quot;</code></p>
<p>By default it&#39;s set, but if for whatever reason it&#39;s not, and you didn&#39;t knowingly do it yourself, you can set it
with <code>shopt -s progcomp</code>. That can be added to your <code>.bashrc</code>.</p>
<p>If that&#39;s not the problem, you will have to debug this the old fashioned way. Use <code>echo &quot;$VARNAME&quot;</code> to see the values
of variables. Finally you may want to read the docs.</p>
<p>I didn&#39;t initially suggest reading the docs because, unfortunately, the documentation for anything contained in the
bash man pages is terribly undiscoverable, difficult to search, and not always easy to read <sup><a id="footnote-ref-3" href="#footnote-3" data-footnote-ref aria-describedby="footnote-label">4</a></sup>. All of the above
is in the bash man pages. Here&#39;s how you can find the relevant docs:</p>
<ul>
<li><code>man bash</code> to open the documentation for bash itself.</li>
<li>Press <code>/</code> to start searching.</li>
<li>Once you&#39;ve entered your search term hit &quot;Enter&quot; and then use <code>n</code> and <code>N</code> to search forward and backwards
(respectively) for the content you want.</li>
<li>You&#39;ll want the following search terms:<ul>
<li>&quot;Programming Completion&quot; for an overview of completion in bash.</li>
<li>&quot;compgen&quot; for the function that we use to match input with the search term.</li>
<li>&quot;complete&quot; for the function used to tell bash to use programmable completion for a given command.</li>
</ul>
</li>
</ul>
<p>Update: After completing my first draft of this post, Niall pointed me to the far more readable and digestible <a href="http://www.tldp.org/LDP/abs/html/tabexpansion.html">TLDP</a>.</p>
<h2>In Closing</h2>
<p>Bash Programmable Autocompletion is powerful, but intimidating at first. Hopefully this post helps you get started.
If you build something awesome write it up and ping us on twitter! We&#39;re <a href="https://twitter.com/apsislabs">@ApsisLabs</a>.</p>
<section class="footnotes" data-footnotes>
<h2 id="footnote-label" class="sr-only">Footnotes</h2>
<ol>
<li id="footnote-2">
<p><a href="https://xkcd.com/1205/">xkcd is relevant here</a> <a href="#footnote-ref-2" data-footnote-backref aria-label="Back to reference 2">↩</a></p>
</li>
<li id="footnote-1">
<p>Couldn&#39;t use an alias, because aliases can&#39;t interpolate arguments, they&#39;re strictly dumb text replacements , and they always include a space at the end. <a href="#footnote-ref-1" data-footnote-backref aria-label="Back to reference 1">↩</a></p>
</li>
<li id="footnote-4">
<p>One with a head cold, limited exposure to bash internals like autocomplete, and more important work to accomplish. <a href="#footnote-ref-4" data-footnote-backref aria-label="Back to reference 4">↩</a></p>
</li>
<li id="footnote-3">
<p>Man pages, as useful as they are, are dinosaurs <a href="https://unix.stackexchange.com/a/18161/34182">from a prehistoric time before hypertext was invented</a>. You can&#39;t follow bolded text as if they were links. <a href="#footnote-ref-3" data-footnote-backref aria-label="Back to reference 3">↩</a></p>
</li>
</ol>
</section>
</div><footer class="Post_post__meta__j55Gy">Posted on<!-- --> <time dateTime="2018-01-08" itemProp="datePublished">2018-01-08</time> <!-- -->by<!-- --> <span itemProp="author" itemscope="" itemType="http://schema.org/Person"><span itemProp="name">chris</span></span></footer></article></div></div></div></section><section class="Section_section__rDOJq Section_section--gray__Xj11z Section_section--bordered__v_Az0"><div class="Section_section__mask__iGDmr"><div class="Section_section__guides__rCsOH"></div></div><div class="Section_section__container__9Fwqr"><div class="Section_section__content__Klb0i"><footer class="Footer_footer__W37AO"><div class="Row_row__1wkRY Row_row--top__qt9xi"><div><a class="Footer_footer__logo__G9sAT" href="/"><h1 class="LogoType_logotype__iHLMP Footer_footer__logotype__Olnhi"><svg viewBox="0 0 64 64" fill="none" xmlns="http://www.w3.org/2000/svg" class="LogoType_logotype__planet__674Ub" width="18" height="18"><path fill-rule="evenodd" clip-rule="evenodd" d="M32 64C49.6731 64 64 49.6731 64 32C64 14.3269 49.6731 0 32 0C14.3269 0 0 14.3269 0 32C0 49.6731 14.3269 64 32 64ZM32 61C48.0163 61 61 48.0163 61 32C61 15.9837 48.0163 3 32 3C15.9837 3 3 15.9837 3 32C3 48.0163 15.9837 61 32 61ZM58 32C58 46.3594 46.3594 58 32 58C17.6406 58 6 46.3594 6 32C6 17.6406 17.6406 6 32 6C46.3594 6 58 17.6406 58 32ZM44 26C47.3137 26 50 23.3137 50 20C50 16.6863 47.3137 14 44 14C40.6863 14 38 16.6863 38 20C38 23.3137 40.6863 26 44 26Z" fill="currentColor"></path></svg>Apsis Labs</h1></a><small><ul role="list" class="inline_list"><li>Copyright <!-- -->2024<!-- --> Apsis Labs, LLP</li><li><a class="link" target="_blank" href="https://github.com/apsislabs">Github</a></li><li><a class="link" target="_blank" href="https://www.linkedin.com/company/apsislabs/">LinkedIn</a></li><li><a class="link" href="mailto:contact@apsis.io">contact@apsis.io</a></li></ul></small><small><ul role="list" class="inline_list"><li><a class="link" href="/privacy/">Privacy Policy</a></li><li><a class="link" href="/conduct/">Code of Conduct</a></li><li><a class="link" href="/mdbn/">Data Breach Notification Policy</a></li></ul></small></div><div class="Footer_footer__tagline_container__19nxT"><h4 class="Footer_footer__tagline__gO_GO">Distributed &amp; Horizontally Scalable</h4><small><ul class="inline_list"><li>❤️ from:</li><li>Seattle</li><li>Boulder</li><li>Boston</li><li>Portland</li><li>Hartford</li></ul></small></div></div></footer></div></div></section></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"postData":{"id":"bash_completion","href":{"pathname":"/blog/[year]/[month]/[day]/[slug]","query":{"year":"2018","month":"01","day":"08","slug":"bash_completion"}},"contentHtml":"\u003cp\u003eEvery developer should have at least a basic mastery of their command line. I\u0026#39;d argue\nthat part of that mastery is to develop a set of customizations they take with them\nwherever they go. These customizations should make things you do all the time faster.\nObviously there are diminshing returns here\u003csup\u003e\u003ca id=\"footnote-ref-2\" href=\"#footnote-2\" data-footnote-ref aria-describedby=\"footnote-label\"\u003e1\u003c/a\u003e\u003c/sup\u003e.\u003c/p\u003e\n\u003cp\u003eSome of my customizations include bash aliases for my most used git commands. \u003ccode\u003ega\u003c/code\u003e is\nshort for \u003ccode\u003egit add\u003c/code\u003e, \u003ccode\u003egap\u003c/code\u003e is short for \u003ccode\u003egit add -p\u003c/code\u003e, etc. I also like to have a\nsyntax highlighted \u003ccode\u003ecat\u003c/code\u003e and \u003ccode\u003eless\u003c/code\u003e available to me using \u003ca href=\"http://pygments.org/\"\u003ePygments\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eToday I added something I\u0026#39;ve wanted for a long time: a \u003ccode\u003ecd\u003c/code\u003e that works relative to\nthe directory I do most of my development work in. Now I can run \u003ccode\u003ecdx subdir_of_x\u003c/code\u003e\nand it will take me to \u003ccode\u003e~/x/subdir_of_x\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eYou may be wondering \u0026quot;Why use precious kilobytes of storage and hours of time writing\nthis up!?\u0026quot; And you\u0026#39;d be corect. By itself, this is not worthy of a blog post.\nI, however, also added autocompletion for the contents of that directory, and \u003cem\u003ethat\u003c/em\u003e\nis worth writing about.\u003c/p\u003e\n\u003cp\u003eWhat follows is a short tutorial on bash autocompletion and a tiny bit of bash programming\ninformation. It assumes you have a working knowledge of programming, and at least passing\nfamiliarity with your terminal.\u003c/p\u003e\n\u003ch2\u003eThe Function\u003c/h2\u003e\n\u003cp\u003eIn and of itself, this a very easy function\u003csup\u003e\u003ca id=\"footnote-ref-1\" href=\"#footnote-1\" data-footnote-ref aria-describedby=\"footnote-label\"\u003e2\u003c/a\u003e\u003c/sup\u003e to write. In your \u003ccode\u003e~/.bashrc\u003c/code\u003e add:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunction cdx {\n    cd \u0026quot;$HOME/x/$1\u0026quot;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eMy first test looked like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ecdx my_code  \u0026lt;TAB\u0026gt;  _base\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNo autocomplete, just big gaping tabs in the middle of my command. What\u0026#39;s an enterprising\ndeveloper\u003csup\u003e\u003ca id=\"footnote-ref-4\" href=\"#footnote-4\" data-footnote-ref aria-describedby=\"footnote-label\"\u003e3\u003c/a\u003e\u003c/sup\u003e to do? Spend the morning figuring it out, of course.\u003c/p\u003e\n\u003ch2\u003eThe Code\u003c/h2\u003e\n\u003cp\u003eFirst, the good stuff. All together, when placed in your \u003ccode\u003e~/.bashrc\u003c/code\u003e and \u003ccode\u003esource\u003c/code\u003eed,\nthe following works for hypothetical directory \u003ccode\u003ex\u003c/code\u003e in your home directory using the new\ncommand \u003ccode\u003ecdx\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunction cdx {\n    cd \u0026quot;$HOME/x/$1\u0026quot;\n}\nfunction _cdx {\n    local cur opts\n\n    opts=\u0026quot;$(ls -1 ~/x)\u0026quot;\n    cur=\u0026quot;${COMP_WORDS[COMP_CWORD]}\u0026quot;\n\n    COMPREPLY=( $(compgen -W \u0026quot;${opts}\u0026quot; -- ${cur}) )\n    return 0\n}\ncomplete -F _cdx cdx\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eTo make it work:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eInsert this in \u003ccode\u003e~/.bashrc\u003c/code\u003e.\u003c/li\u003e\n\u003cli\u003eReplace all instances of \u0026quot;x\u0026quot; with a directory from your \u003ccode\u003e$HOME\u003c/code\u003e directory.\u003c/li\u003e\n\u003cli\u003eCall \u003ccode\u003esource ~/.bashrc\u003c/code\u003e.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eYou may want to rename \u003ccode\u003ecdx\u003c/code\u003e with a more intuitive name (for Apsis code, for example,\nI\u0026#39;d use \u003ccode\u003ecda\u003c/code\u003e and \u003ccode\u003e_cda\u003c/code\u003e).\u003c/p\u003e\n\u003ch2\u003eThe Explanation\u003c/h2\u003e\n\u003cp\u003eNow to break the \u003ccode\u003e_cdx\u003c/code\u003e function down. When it gets obvious feel free to skip to the end, I\u0026#39;ve\nattempted to order this from most specific to broadest bash knowledge. (In order of \u003cem\u003emy\u003c/em\u003e current\nknowledge of bash). I\u0026#39;ve left the most basic stuff (like explaining \u003ccode\u003els\u003c/code\u003e) out.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cp\u003e\u003ccode\u003ecomplete -F _cdx cdx\u003c/code\u003e is how you let bash know to attempt an autocomplete. In English it\u0026#39;s:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eWhen I run the cdx command please use the function _cdx to autocomplete the command.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003ccode\u003ecompgen -W \u0026quot;${opts}\u0026quot; -- ${cur}\u003c/code\u003e is the function that searches an array of possibilities (\u003ccode\u003e-W\u003c/code\u003e)\nfor the text after \u003ccode\u003e--\u003c/code\u003e. It\u0026#39;s pretty rigid: no fuzzy searching, no autocorrecting. It just returns\n\u0026quot;things from the array that start with what you typed.\u0026quot; You are free to replace it with\nwhatever you want as long as it too returns an array (space separated string) of the options.\nIn English:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003ePlease give me all the words in the string \u0026#39;opts\u0026#39; that start with what\u0026#39;s in \u0026#39;cur\u0026#39;.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003ccode\u003eCOMPREPLY\u003c/code\u003e is basically the return value of this function. Whatever array you return here will be\npresented to you on the command line as options for autocompletion. In English:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eHere\u0026#39;s what I want to pick from when autocompleting with the current inputs.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003ccode\u003ecur=\u0026quot;${COMP_WORDS[COMP_CWORD]}\u0026quot;\u003c/code\u003e is setting \u003ccode\u003ecur\u003c/code\u003e to the last word on the command line. \u003ccode\u003eCOMP_WORDS\u003c/code\u003e\nand \u003ccode\u003eCOMP_CWORD\u003c/code\u003e are the inputs to this function. (You can actually make them real bash function\nparameters if you want to, but they\u0026#39;re already acceptably named). They are special bash variables\nthat are only available in completion functions. \u003ccode\u003eCOMP_WORDS\u003c/code\u003e is the array of strings currently\nentered on the command line. \u003ccode\u003eCOMP_CWORDS\u003c/code\u003e is the current length of the \u003ccode\u003eCOMP_WORDS\u003c/code\u003e array. In English:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eSet the variable \u0026#39;cur\u0026#39; to the last word on the command line.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003ccode\u003eopts=\u0026quot;$(ls -1 ~/x)\u0026quot;\u003c/code\u003e is where we set the available options by creating an array (space separated string)\nfrom the output of \u003ccode\u003els -1 ~/x\u003c/code\u003e. This gets used in the \u003ccode\u003ecompgen\u003c/code\u003e command. In English:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eSet \u0026quot;opts\u0026quot; to the output of \u0026quot;ls -1 ~/x\u0026quot; as the list of potential options to autocomplete from.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003ccode\u003elocal cur opts\u003c/code\u003e is a declaration of the cur and opts variables. By using \u003ccode\u003elocal\u003c/code\u003e we avoid cluttering\nthe global variable namespace. In English:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eI\u0026#39;m going to use the cur and opts variables. You can forget them when this function ends.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003ccode\u003ereturn 0\u003c/code\u003e quits the function and sets the bash exit code. \u003ccode\u003e0\u003c/code\u003e is success, all other values are failures.\nThis is useful in other bash scripts when you want to use it with \u003ccode\u003e\u0026amp;\u0026amp;\u003c/code\u003e \u003ccode\u003e||\u003c/code\u003e. Here it simply informs bash\nthat the completion script was successful. In English:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eIT WORKED! Show the user the values in \u0026quot;COMPREPLY\u0026quot;!\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2\u003eImprovements\u003c/h2\u003e\n\u003cp\u003eThis is a great start, and super useful as is, but there is more that could be done:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cp\u003eGoing deeper: it\u0026#39;d be nice if I could keep autocompleting deeper into the directory, so \u003ccode\u003ecdx ydir/zdi\u003c/code\u003e\ncould autocomplete to \u003ccode\u003e~/x/ydir/zdir\u003c/code\u003e. This would involve making the \u003ccode\u003eopts=\u003c/code\u003e line more intelligent.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eFuzzy searching: I am great at typos. It\u0026#39;d be nice if I could replace \u003ccode\u003ecompgen\u003c/code\u003e with something more\nintelligent that will ignore small typos.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eMore generic: Being able to match \u003ccode\u003ecda\u003c/code\u003e or \u003ccode\u003ecdb\u003c/code\u003e to switch to subdirectories of \u003ccode\u003e~/apsis\u003c/code\u003e or \u003ccode\u003e~/bread\u003c/code\u003e\nwould be nice. Writing a script to handle the unique cases when bash fires up would be easily doable.\nIt would, however, require separate autocomplete functions for each named function becuase \u003ccode\u003ecomplete\u003c/code\u003e\nonly accepts literal command names.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2\u003eTroubleshooting/Further Reading\u003c/h2\u003e\n\u003cp\u003eIf the above doesn\u0026#39;t work it\u0026#39;s possible your \u003ccode\u003eprogcomp\u003c/code\u003e bash option isn\u0026#39;t set. You can check with:\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eecho $BASHOPTS | grep -q progcomp \u0026amp;\u0026amp; echo \u0026quot;YES\u0026quot; || echo \u0026quot;NO\u0026quot;\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eBy default it\u0026#39;s set, but if for whatever reason it\u0026#39;s not, and you didn\u0026#39;t knowingly do it yourself, you can set it\nwith \u003ccode\u003eshopt -s progcomp\u003c/code\u003e. That can be added to your \u003ccode\u003e.bashrc\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eIf that\u0026#39;s not the problem, you will have to debug this the old fashioned way. Use \u003ccode\u003eecho \u0026quot;$VARNAME\u0026quot;\u003c/code\u003e to see the values\nof variables. Finally you may want to read the docs.\u003c/p\u003e\n\u003cp\u003eI didn\u0026#39;t initially suggest reading the docs because, unfortunately, the documentation for anything contained in the\nbash man pages is terribly undiscoverable, difficult to search, and not always easy to read \u003csup\u003e\u003ca id=\"footnote-ref-3\" href=\"#footnote-3\" data-footnote-ref aria-describedby=\"footnote-label\"\u003e4\u003c/a\u003e\u003c/sup\u003e. All of the above\nis in the bash man pages. Here\u0026#39;s how you can find the relevant docs:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eman bash\u003c/code\u003e to open the documentation for bash itself.\u003c/li\u003e\n\u003cli\u003ePress \u003ccode\u003e/\u003c/code\u003e to start searching.\u003c/li\u003e\n\u003cli\u003eOnce you\u0026#39;ve entered your search term hit \u0026quot;Enter\u0026quot; and then use \u003ccode\u003en\u003c/code\u003e and \u003ccode\u003eN\u003c/code\u003e to search forward and backwards\n(respectively) for the content you want.\u003c/li\u003e\n\u003cli\u003eYou\u0026#39;ll want the following search terms:\u003cul\u003e\n\u003cli\u003e\u0026quot;Programming Completion\u0026quot; for an overview of completion in bash.\u003c/li\u003e\n\u003cli\u003e\u0026quot;compgen\u0026quot; for the function that we use to match input with the search term.\u003c/li\u003e\n\u003cli\u003e\u0026quot;complete\u0026quot; for the function used to tell bash to use programmable completion for a given command.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eUpdate: After completing my first draft of this post, Niall pointed me to the far more readable and digestible \u003ca href=\"http://www.tldp.org/LDP/abs/html/tabexpansion.html\"\u003eTLDP\u003c/a\u003e.\u003c/p\u003e\n\u003ch2\u003eIn Closing\u003c/h2\u003e\n\u003cp\u003eBash Programmable Autocompletion is powerful, but intimidating at first. Hopefully this post helps you get started.\nIf you build something awesome write it up and ping us on twitter! We\u0026#39;re \u003ca href=\"https://twitter.com/apsislabs\"\u003e@ApsisLabs\u003c/a\u003e.\u003c/p\u003e\n\u003csection class=\"footnotes\" data-footnotes\u003e\n\u003ch2 id=\"footnote-label\" class=\"sr-only\"\u003eFootnotes\u003c/h2\u003e\n\u003col\u003e\n\u003cli id=\"footnote-2\"\u003e\n\u003cp\u003e\u003ca href=\"https://xkcd.com/1205/\"\u003exkcd is relevant here\u003c/a\u003e \u003ca href=\"#footnote-ref-2\" data-footnote-backref aria-label=\"Back to reference 2\"\u003e↩\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli id=\"footnote-1\"\u003e\n\u003cp\u003eCouldn\u0026#39;t use an alias, because aliases can\u0026#39;t interpolate arguments, they\u0026#39;re strictly dumb text replacements , and they always include a space at the end. \u003ca href=\"#footnote-ref-1\" data-footnote-backref aria-label=\"Back to reference 1\"\u003e↩\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli id=\"footnote-4\"\u003e\n\u003cp\u003eOne with a head cold, limited exposure to bash internals like autocomplete, and more important work to accomplish. \u003ca href=\"#footnote-ref-4\" data-footnote-backref aria-label=\"Back to reference 4\"\u003e↩\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli id=\"footnote-3\"\u003e\n\u003cp\u003eMan pages, as useful as they are, are dinosaurs \u003ca href=\"https://unix.stackexchange.com/a/18161/34182\"\u003efrom a prehistoric time before hypertext was invented\u003c/a\u003e. You can\u0026#39;t follow bolded text as if they were links. \u003ca href=\"#footnote-ref-3\" data-footnote-backref aria-label=\"Back to reference 3\"\u003e↩\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/section\u003e\n","layout":"post","author":"chris","title":"Save Time with Bash Programmable Autocompletion","image":"/img/posts/bash.gif","excerpt":"\u003cp\u003eEvery developer should have at least a basic mastery of their command line. I\u0026#39;d argue\nthat part of that mastery is to develop a set of customizations they take with them\nwherever they go. These customizations should make things you do all the time faster.\nObviously there are diminshing returns here[^2].\u003c/p\u003e\n\u003cp\u003eSome of my customizations include bash aliases for my most used git commands\u003c/p\u003e\n","date":"2018-01-08"}},"__N_SSG":true},"page":"/blog/[year]/[month]/[day]/[slug]","query":{"year":"2018","month":"01","day":"08","slug":"bash_completion"},"buildId":"B7QLQHINFLJsMXi5mwaz5","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>
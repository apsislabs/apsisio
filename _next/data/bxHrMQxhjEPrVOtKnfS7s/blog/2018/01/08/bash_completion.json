{"pageProps":{"postData":{"id":"bash_completion","href":{"pathname":"/blog/[year]/[month]/[day]/[slug]","query":{"year":"2018","month":"01","day":"08","slug":"bash_completion"}},"contentHtml":"<p>Every developer should have at least a basic mastery of their command line. I'd argue\nthat part of that mastery is to develop a set of customizations they take with them\nwherever they go. These customizations should make things you do all the time faster.\nObviously there are diminshing returns here<sup><a href=\"#user-content-fn-2\" id=\"user-content-user-content-fnref-2\" aria-describedby=\"footnote-label\">1</a></sup>.</p>\n<p>Some of my customizations include bash aliases for my most used git commands. <code>ga</code> is\nshort for <code>git add</code>, <code>gap</code> is short for <code>git add -p</code>, etc. I also like to have a\nsyntax highlighted <code>cat</code> and <code>less</code> available to me using <a href=\"http://pygments.org/\">Pygments</a>.</p>\n<p>Today I added something I've wanted for a long time: a <code>cd</code> that works relative to\nthe directory I do most of my development work in. Now I can run <code>cdx subdir_of_x</code>\nand it will take me to <code>~/x/subdir_of_x</code>.</p>\n<p>You may be wondering \"Why use precious kilobytes of storage and hours of time writing\nthis up!?\" And you'd be corect. By itself, this is not worthy of a blog post.\nI, however, also added autocompletion for the contents of that directory, and <em>that</em>\nis worth writing about.</p>\n<p>What follows is a short tutorial on bash autocompletion and a tiny bit of bash programming\ninformation. It assumes you have a working knowledge of programming, and at least passing\nfamiliarity with your terminal.</p>\n<h2>The Function</h2>\n<p>In and of itself, this a very easy function<sup><a href=\"#user-content-fn-1\" id=\"user-content-user-content-fnref-1\" aria-describedby=\"footnote-label\">2</a></sup> to write. In your <code>~/.bashrc</code> add:</p>\n<div><pre><code>function cdx {\n    cd &#x26;quot;$HOME/x/$1&#x26;quot;\n}</code></pre></div>\n<p>My first test looked like this:</p>\n<div><pre><code>cdx my_code  &#x26;lt;TAB&#x26;gt;  _base</code></pre></div>\n<p>No autocomplete, just big gaping tabs in the middle of my command. What's an enterprising\ndeveloper<sup><a href=\"#user-content-fn-4\" id=\"user-content-user-content-fnref-4\" aria-describedby=\"footnote-label\">3</a></sup> to do? Spend the morning figuring it out, of course.</p>\n<h2>The Code</h2>\n<p>First, the good stuff. All together, when placed in your <code>~/.bashrc</code> and <code>source</code>ed,\nthe following works for hypothetical directory <code>x</code> in your home directory using the new\ncommand <code>cdx</code>:</p>\n<div><pre><code>function cdx {\n    cd &#x26;quot;$HOME/x/$1&#x26;quot;\n}\nfunction _cdx {\n    local cur opts\n\n    opts=&#x26;quot;$(ls -1 ~/x)&#x26;quot;\n    cur=&#x26;quot;${COMP_WORDS[COMP_CWORD]}&#x26;quot;\n\n    COMPREPLY=( $(compgen -W &#x26;quot;${opts}&#x26;quot; -- ${cur}) )\n    return 0\n}\ncomplete -F _cdx cdx</code></pre></div>\n<p>To make it work:</p>\n<ol>\n<li>Insert this in <code>~/.bashrc</code>.</li>\n<li>Replace all instances of \"x\" with a directory from your <code>$HOME</code> directory.</li>\n<li>Call <code>source ~/.bashrc</code>.</li>\n</ol>\n<p>You may want to rename <code>cdx</code> with a more intuitive name (for Apsis code, for example,\nI'd use <code>cda</code> and <code>_cda</code>).</p>\n<h2>The Explanation</h2>\n<p>Now to break the <code>_cdx</code> function down. When it gets obvious feel free to skip to the end, I've\nattempted to order this from most specific to broadest bash knowledge. (In order of <em>my</em> current\nknowledge of bash). I've left the most basic stuff (like explaining <code>ls</code>) out.</p>\n<ol>\n<li>\n<p><code>complete -F _cdx cdx</code> is how you let bash know to attempt an autocomplete. In English it's:</p>\n<blockquote>\n<p>When I run the cdx command please use the function _cdx to autocomplete the command.</p>\n</blockquote>\n</li>\n<li>\n<p><code>compgen -W \"${opts}\" -- ${cur}</code> is the function that searches an array of possibilities (<code>-W</code>)\nfor the text after <code>--</code>. It's pretty rigid: no fuzzy searching, no autocorrecting. It just returns\n\"things from the array that start with what you typed.\" You are free to replace it with\nwhatever you want as long as it too returns an array (space separated string) of the options.\nIn English:</p>\n<blockquote>\n<p>Please give me all the words in the string 'opts' that start with what's in 'cur'.</p>\n</blockquote>\n</li>\n<li>\n<p><code>COMPREPLY</code> is basically the return value of this function. Whatever array you return here will be\npresented to you on the command line as options for autocompletion. In English:</p>\n<blockquote>\n<p>Here's what I want to pick from when autocompleting with the current inputs.</p>\n</blockquote>\n</li>\n<li>\n<p><code>cur=\"${COMP_WORDS[COMP_CWORD]}\"</code> is setting <code>cur</code> to the last word on the command line. <code>COMP_WORDS</code>\nand <code>COMP_CWORD</code> are the inputs to this function. (You can actually make them real bash function\nparameters if you want to, but they're already acceptably named). They are special bash variables\nthat are only available in completion functions. <code>COMP_WORDS</code> is the array of strings currently\nentered on the command line. <code>COMP_CWORDS</code> is the current length of the <code>COMP_WORDS</code> array. In English:</p>\n<blockquote>\n<p>Set the variable 'cur' to the last word on the command line.</p>\n</blockquote>\n</li>\n<li>\n<p><code>opts=\"$(ls -1 ~/x)\"</code> is where we set the available options by creating an array (space separated string)\nfrom the output of <code>ls -1 ~/x</code>. This gets used in the <code>compgen</code> command. In English:</p>\n<blockquote>\n<p>Set \"opts\" to the output of \"ls -1 ~/x\" as the list of potential options to autocomplete from.</p>\n</blockquote>\n</li>\n<li>\n<p><code>local cur opts</code> is a declaration of the cur and opts variables. By using <code>local</code> we avoid cluttering\nthe global variable namespace. In English:</p>\n<blockquote>\n<p>I'm going to use the cur and opts variables. You can forget them when this function ends.</p>\n</blockquote>\n</li>\n<li>\n<p><code>return 0</code> quits the function and sets the bash exit code. <code>0</code> is success, all other values are failures.\nThis is useful in other bash scripts when you want to use it with <code>&#x26;&#x26;</code> <code>||</code>. Here it simply informs bash\nthat the completion script was successful. In English:</p>\n<blockquote>\n<p>IT WORKED! Show the user the values in \"COMPREPLY\"!</p>\n</blockquote>\n</li>\n</ol>\n<h2>Improvements</h2>\n<p>This is a great start, and super useful as is, but there is more that could be done:</p>\n<ol>\n<li>\n<p>Going deeper: it'd be nice if I could keep autocompleting deeper into the directory, so <code>cdx ydir/zdi</code>\ncould autocomplete to <code>~/x/ydir/zdir</code>. This would involve making the <code>opts=</code> line more intelligent.</p>\n</li>\n<li>\n<p>Fuzzy searching: I am great at typos. It'd be nice if I could replace <code>compgen</code> with something more\nintelligent that will ignore small typos.</p>\n</li>\n<li>\n<p>More generic: Being able to match <code>cda</code> or <code>cdb</code> to switch to subdirectories of <code>~/apsis</code> or <code>~/bread</code>\nwould be nice. Writing a script to handle the unique cases when bash fires up would be easily doable.\nIt would, however, require separate autocomplete functions for each named function becuase <code>complete</code>\nonly accepts literal command names.</p>\n</li>\n</ol>\n<h2>Troubleshooting/Further Reading</h2>\n<p>If the above doesn't work it's possible your <code>progcomp</code> bash option isn't set. You can check with:</p>\n<p><code>echo $BASHOPTS | grep -q progcomp &#x26;&#x26; echo \"YES\" || echo \"NO\"</code></p>\n<p>By default it's set, but if for whatever reason it's not, and you didn't knowingly do it yourself, you can set it\nwith <code>shopt -s progcomp</code>. That can be added to your <code>.bashrc</code>.</p>\n<p>If that's not the problem, you will have to debug this the old fashioned way. Use <code>echo \"$VARNAME\"</code> to see the values\nof variables. Finally you may want to read the docs.</p>\n<p>I didn't initially suggest reading the docs because, unfortunately, the documentation for anything contained in the\nbash man pages is terribly undiscoverable, difficult to search, and not always easy to read <sup><a href=\"#user-content-fn-3\" id=\"user-content-user-content-fnref-3\" aria-describedby=\"footnote-label\">4</a></sup>. All of the above\nis in the bash man pages. Here's how you can find the relevant docs:</p>\n<ul>\n<li><code>man bash</code> to open the documentation for bash itself.</li>\n<li>Press <code>/</code> to start searching.</li>\n<li>Once you've entered your search term hit \"Enter\" and then use <code>n</code> and <code>N</code> to search forward and backwards\n(respectively) for the content you want.</li>\n<li>You'll want the following search terms:\n<ul>\n<li>\"Programming Completion\" for an overview of completion in bash.</li>\n<li>\"compgen\" for the function that we use to match input with the search term.</li>\n<li>\"complete\" for the function used to tell bash to use programmable completion for a given command.</li>\n</ul>\n</li>\n</ul>\n<p>Update: After completing my first draft of this post, Niall pointed me to the far more readable and digestible <a href=\"http://www.tldp.org/LDP/abs/html/tabexpansion.html\">TLDP</a>.</p>\n<h2>In Closing</h2>\n<p>Bash Programmable Autocompletion is powerful, but intimidating at first. Hopefully this post helps you get started.\nIf you build something awesome write it up and ping us on twitter! We're <a href=\"https://twitter.com/apsislabs\">@ApsisLabs</a>.</p>\n<h2 id=\"user-content-footnote-label\">Footnotes</h2>\n<ol>\n<li id=\"user-content-user-content-fn-2\">\n<p><a href=\"https://xkcd.com/1205/\">xkcd is relevant here</a> <a href=\"#user-content-fnref-2\" aria-label=\"Back to content\">↩</a></p>\n</li>\n<li id=\"user-content-user-content-fn-1\">\n<p>Couldn't use an alias, because aliases can't interpolate arguments, they're strictly dumb text replacements , and they always include a space at the end. <a href=\"#user-content-fnref-1\" aria-label=\"Back to content\">↩</a></p>\n</li>\n<li id=\"user-content-user-content-fn-4\">\n<p>One with a head cold, limited exposure to bash internals like autocomplete, and more important work to accomplish. <a href=\"#user-content-fnref-4\" aria-label=\"Back to content\">↩</a></p>\n</li>\n<li id=\"user-content-user-content-fn-3\">\n<p>Man pages, as useful as they are, are dinosaurs <a href=\"https://unix.stackexchange.com/a/18161/34182\">from a prehistoric time before hypertext was invented</a>. You can't follow bolded text as if they were links. <a href=\"#user-content-fnref-3\" aria-label=\"Back to content\">↩</a></p>\n</li>\n</ol>\n","layout":"post","author":"chris","title":"Save Time with Bash Programmable Autocompletion","image":"/img/posts/bash.gif","excerpt":"<p>Every developer should have at least a basic mastery of their command line. I'd argue\nthat part of that mastery is to develop a set of customizations they take with them\nwherever they go. These customizations should make things you do all the time faster.\nObviously there are diminshing returns here[^2].</p>\n<p>Some of my customizations include bash aliases for my most used git commands</p>\n","date":"2018-01-08"}},"__N_SSG":true}
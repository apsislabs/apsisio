<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>Blog: <!-- -->Parsing JSON with Types (Part 1)<!-- --> | Apsis Labs</title><meta name="next-head-count" content="3"/><link rel="preload" href="/_next/static/media/a34f9d1faa5f3315-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/_next/static/media/37e85b36581a02ab-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/_next/static/media/a9387c470a117487-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/_next/static/media/3478b6abef19b3b3-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/_next/static/media/035951aefad7b653-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/_next/static/css/902fc33b34da2cf3.css" as="style"/><link rel="stylesheet" href="/_next/static/css/902fc33b34da2cf3.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b00c133a4a34a799.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b00c133a4a34a799.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-42372ed130431b0a.js"></script><script src="/_next/static/chunks/webpack-38cee4c0e358b1a3.js" defer=""></script><script src="/_next/static/chunks/framework-64ad27b21261a9ce.js" defer=""></script><script src="/_next/static/chunks/main-58eb4e77e43e295f.js" defer=""></script><script src="/_next/static/chunks/pages/_app-117cd370142abc6d.js" defer=""></script><script src="/_next/static/chunks/25-c9e36e11cdefe32e.js" defer=""></script><script src="/_next/static/chunks/pages/blog/%5Byear%5D/%5Bmonth%5D/%5Bday%5D/%5Bslug%5D-90b6ae62b9b706e4.js" defer=""></script><script src="/_next/static/W4pufNDEt06x3-24viEGe/_buildManifest.js" defer=""></script><script src="/_next/static/W4pufNDEt06x3-24viEGe/_ssgManifest.js" defer=""></script><style id="__jsx-32619431">:root{--font-inter:'__Inter_36bd41', '__Inter_Fallback_36bd41';--font-mono:'__IBM_Plex_Mono_332d21', '__IBM_Plex_Mono_Fallback_332d21'}</style></head><body><div id="__next"><section class="Section_section__rDOJq Section_section--bordered__v_Az0"><div class="Section_section__mask__iGDmr"></div><div class="Section_section__container__9Fwqr"><div class="Section_section__content__Klb0i"><nav class="Navbar_navbar__pYr0W"><a class="Navbar_navbar__logo__NNGhf" href="/"><h1 class="LogoType_logotype__iHLMP"><svg viewBox="0 0 64 64" fill="none" xmlns="http://www.w3.org/2000/svg" class="LogoType_logotype__planet__674Ub" width="24" height="24"><path fill-rule="evenodd" clip-rule="evenodd" d="M32 64C49.6731 64 64 49.6731 64 32C64 14.3269 49.6731 0 32 0C14.3269 0 0 14.3269 0 32C0 49.6731 14.3269 64 32 64ZM32 61C48.0163 61 61 48.0163 61 32C61 15.9837 48.0163 3 32 3C15.9837 3 3 15.9837 3 32C3 48.0163 15.9837 61 32 61ZM58 32C58 46.3594 46.3594 58 32 58C17.6406 58 6 46.3594 6 32C6 17.6406 17.6406 6 32 6C46.3594 6 58 17.6406 58 32ZM44 26C47.3137 26 50 23.3137 50 20C50 16.6863 47.3137 14 44 14C40.6863 14 38 16.6863 38 20C38 23.3137 40.6863 26 44 26Z" fill="currentColor"></path></svg>Apsis Labs</h1></a><nav class="Navbar_navbar__nav__YFZzV"><a class="Navbar_navbar__nav_item__OpfdQ" href="/">Home</a><a class="Navbar_navbar__nav_item__OpfdQ" href="/blog/">Blog</a></nav></nav></div></div></section><section class="Section_section__rDOJq Section_section--spaced__Ihmp2 Section_section--narrow__GIboH"><div class="Section_section__mask__iGDmr"></div><div class="Section_section__container__9Fwqr"><div class="Section_section__content__Klb0i"><div class="Post_post-wrapper__s850H"><article class="Post_post__m_Xor" itemType="http://schema.org/BlogPosting"><header class="Post_post__header__pEZ4C"><div><h1 class="Post_post__title__eUeKR"><a href="/blog/2017/03/03/parsing-json-with-types-1/">Parsing JSON with Types (Part 1)</a></h1><footer class="Post_post__meta__j55Gy">Posted on<!-- --> <time dateTime="2017-03-03" itemProp="datePublished">2017-03-03</time> <!-- -->by<!-- --> <span itemProp="author" itemscope="" itemType="http://schema.org/Person"><span itemProp="name">niall</span></span></footer></div><div class="Post_post__image-wrapper__mjNlP"><img src="/img/posts/minified.jpg" alt="Parsing JSON with Types (Part 1)" class="Post_post__image__Dbjks" data-action="zoom"/></div><small class="Post_post__photo-credit__XuOL7">Image by <!-- -->Markus Spiske</small></header><div class="Post_post__content__SHRW1"><p>I like to have well-defined models of my application data, especially at service boundaries.  I usually also define types in my application code to reflect these models.  When data are sent from a service, their values are serialized and their types are mapped onto the type system of the serialization format.  Then, when receiving data, I need to deserialize the values <em>and also</em> map the types back into the richer type system of my application code.</p>
<p>In statically typed languages, application frameworks or libraries typically handle this for me.  In dynamically typed languages, the situation is usually worse.  All a library has to go off is the runtime type of the deserialized values, which restricts it to types representable in the serialization format.  For JSON being deserialized into a JavaScript application, this means all I get are strings, numbers, booleans, and arrays or objects (i.e. string-keyed maps) of those basic types.</p>
<p>I want a systematic way to deserialize JSON data into my application types.</p>
<h3>Prior Art</h3>
<p>I thought there must exist a JavaScript package to do this already but I wasn’t able to find anything very promising.<sup><a id="footnote-ref-prior-art" href="#footnote-prior-art" data-footnote-ref aria-describedby="footnote-label">1</a></sup></p>
<p>Some work has been done on recognizing certain types, especially ISO date strings, and parsing them automatically into date objects.  See for example <a href="https://weblog.west-wind.com/posts/2014/Jan/06/JavaScript-JSON-Date-Parsing-and-real-Dates">JavaScript JSON Date Parsing and real Dates</a>.  But this doesn’t let you use application-defined types, and it still involves a lot of guesswork.<sup><a id="footnote-ref-guesswork" href="#footnote-guesswork" data-footnote-ref aria-describedby="footnote-label">2</a></sup></p>
<p>There are some more promising projects like <a href="https://github.com/pd/typed-json">typed-json</a> which attempt to deal with types in general, but these still have significant limitations.  They require type information, like a constructor name, to be embedded in the data.  This couples your service code to the type system of one particular client, which is... not great.  And of course, if you don’t control the service you are receiving data from, this is impossible to implement.</p>
<h3>Type Mapping</h3>
<p>What I really wanted was something that would (a) not require services to be aware of what my client was doing, and (b) give me powerful building blocks for mapping data into my application types.</p>
<p>For clarity, let me define a few terms as they will be used in the remainder of this post before showing you what I made:</p>
<ul>
<li><strong>JSON Object:</strong> A JavaScript object whose values are exclusively JSON types.  This is the kind of object you get back from JSON.parse().</li>
<li><strong>Application Object:</strong> A JavaScript object whose values may include JavaScript’s other built-in types (e.g. Date) and application-defined types (e.g. ES6 classes or objects with custom prototype chains).</li>
<li><strong>Deserialization</strong>: The process of turning a JSON object into an application object.  <strong>Serialization</strong> is the reverse.</li>
<li><strong>Type Mapper:</strong> A JavaScript object with <code>fromJSON</code> and <code>toJSON</code> properties, which are functions that implement deserialization and serialization.</li>
</ul>
<p>Now, on to the code...</p>
<h4>Basic Types</h4>
<p>Basic types are the primitives of a type system.  Based on our definition above, let&#39;s define a few type mappers for basic types:</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> string = {
    <span class="hljs-attr">fromJSON</span>: <span class="hljs-function"><span class="hljs-params">s</span> =&gt;</span> s,
    <span class="hljs-attr">toJSON</span>: <span class="hljs-function"><span class="hljs-params">s</span> =&gt;</span> s
};

<span class="hljs-keyword">const</span> number = {
    <span class="hljs-attr">fromJSON</span>: <span class="hljs-function"><span class="hljs-params">n</span> =&gt;</span> n,
    <span class="hljs-attr">toJSON</span>: <span class="hljs-function"><span class="hljs-params">n</span> =&gt;</span> n
};

<span class="hljs-keyword">const</span> boolean = {
    <span class="hljs-comment">// Left as an exercise for the reader</span>
};
</code></pre><p>It&#39;s brilliant, right?  Well, these types are shared by JSON and JavaScript&#39;s type systems, so there&#39;s nothing to do.  Let&#39;s try dates next:</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> date = {
    <span class="hljs-attr">fromJSON</span>: <span class="hljs-function"><span class="hljs-params">isoString</span> =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(isoString),
    <span class="hljs-attr">toJSON</span>: <span class="hljs-function"><span class="hljs-params">date</span> =&gt;</span> date.<span class="hljs-title function_">toISOString</span>()
};
</code></pre><p>Fantastic.  Of course, we could also represent dates in our application using <a href="https://momentjs.com/">moment</a> and they could be represented in our JSON data as time values (number of milliseconds since Unix epoch).  Then, our date type mapper would look like:</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">import</span> moment <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;moment&#x27;</span>;

<span class="hljs-keyword">const</span> date = {
    <span class="hljs-attr">fromJSON</span>: <span class="hljs-function"><span class="hljs-params">timeValue</span> =&gt;</span> <span class="hljs-title function_">moment</span>(timeValue),
    <span class="hljs-attr">toJSON</span>: <span class="hljs-function"><span class="hljs-params">m</span> =&gt;</span> m.<span class="hljs-title function_">valueOf</span>()
};
</code></pre><p>So even basic type mappers can be redefined based on the needs of the application or the eccentricities of the services it connects to.</p>
<h4>Parameterized Types</h4>
<p>It doesn&#39;t make sense to define all basic type mappers this way.  Some types may be parameterized, e.g. an array of numbers vs. an array of strings.  A <strong>type mapper constructor</strong>, which is a function that returns a type mapper, is a way to implement them.  Let&#39;s define a few type mapper constructors:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">arrayOf</span>(<span class="hljs-params">type</span>) {
    <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">fromJSON</span>: <span class="hljs-function"><span class="hljs-params">array</span> =&gt;</span> array.<span class="hljs-title function_">map</span>(type.<span class="hljs-property">fromJSON</span>),
        <span class="hljs-attr">toJSON</span>:   <span class="hljs-function"><span class="hljs-params">array</span> =&gt;</span> array.<span class="hljs-title function_">map</span>(type.<span class="hljs-property">toJSON</span>)
    };
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">setOf</span>(<span class="hljs-params">type</span>) {
    <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">fromJSON</span>: <span class="hljs-function"><span class="hljs-params">array</span> =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(array.<span class="hljs-title function_">map</span>(type.<span class="hljs-property">fromJSON</span>)),
        <span class="hljs-attr">toJSON</span>:   <span class="hljs-function"><span class="hljs-params">set</span> =&gt;</span> <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(set, type.<span class="hljs-property">toJSON</span>),
    };
}
</code></pre><pre><code class="hljs language-js"><span class="hljs-keyword">const</span> fibonacci = [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>];

<span class="hljs-keyword">let</span> type = <span class="hljs-title function_">arrayOf</span>(number);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(type.<span class="hljs-title function_">fromJSON</span>(fibonacci));
<span class="hljs-comment">// [1, 1, 2, 3, 4]</span>

type = <span class="hljs-title function_">setOf</span>(number);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(type.<span class="hljs-title function_">fromJSON</span>(fibonacci));
<span class="hljs-comment">// Set {1, 2, 3, 4}</span>
</code></pre><p>Note that JavaScript arrays and sets have the same representation in JSON&#39;s type system but we can choose how to deserialize it by specifying a type mapper.</p>
<p>Maps are another useful parameterized type to implement.  In JavaScript, we often use objects if all we need is a string-keyed map, but let&#39;s also add the possibility of using actual Map objects which support keys of any type.  Again, both of these will be represented the same way in JSON&#39;s type system.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">objectOf</span>(<span class="hljs-params">type</span>) {
    <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">fromJSON</span>: <span class="hljs-function"><span class="hljs-params">object</span> =&gt;</span> _.<span class="hljs-title function_">mapValues</span>(object, type.<span class="hljs-property">fromJSON</span>),
        <span class="hljs-attr">toJSON</span>:   <span class="hljs-function"><span class="hljs-params">object</span> =&gt;</span> _.<span class="hljs-title function_">mapValues</span>(object, type.<span class="hljs-property">toJSON</span>),
    };
}

<span class="hljs-comment">// Helper function to map over an array of [key, value] tuples</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">mapEntries</span> = (<span class="hljs-params">mapKey, mapValue</span>) =&gt; <span class="hljs-function"><span class="hljs-params">entries</span> =&gt;</span> entries.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">[key, value]</span>) =&gt;</span> [<span class="hljs-title function_">mapKey</span>(key), <span class="hljs-title function_">mapValue</span>(value)]);

<span class="hljs-keyword">function</span> <span class="hljs-title function_">mapOf</span>(<span class="hljs-params">keyType, valueType</span>) {
    <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">fromJSON</span>: <span class="hljs-function"><span class="hljs-params">object</span> =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>(<span class="hljs-title function_">mapEntries</span>(keyType.<span class="hljs-property">fromJSON</span>, valueType.<span class="hljs-property">fromJSON</span>)(_.<span class="hljs-title function_">toPairs</span>(object))),
        <span class="hljs-attr">toJSON</span>:   <span class="hljs-function"><span class="hljs-params">map</span> =&gt;</span> _.<span class="hljs-title function_">fromPairs</span>(<span class="hljs-title function_">mapEntries</span>(keyType.<span class="hljs-property">toJSON</span>, valueType.<span class="hljs-property">toJSON</span>)(<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(map)))
    };
}
</code></pre><pre><code class="hljs language-js"><span class="hljs-keyword">const</span> holidays = {
    <span class="hljs-string">&quot;2017-01-01&quot;</span>: [<span class="hljs-string">&quot;New Year&#x27;s Day&quot;</span>, <span class="hljs-string">&quot;Public Domain Day&quot;</span>],
    <span class="hljs-string">&quot;2017-01-25&quot;</span>: [<span class="hljs-string">&quot;Republic Day&quot;</span>, <span class="hljs-string">&quot;Australia Day&quot;</span>]
};

<span class="hljs-keyword">let</span> type = <span class="hljs-title function_">objectOf</span>(<span class="hljs-title function_">arrayOf</span>(string));
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(type.<span class="hljs-title function_">fromJSON</span>(holidays));
<span class="hljs-comment">// Object {</span>
<span class="hljs-comment">//    2017-01-01: [&quot;New Year&#x27;s Day&quot;, &quot;Public Domain Day&quot;],</span>
<span class="hljs-comment">//    2017-01-25: [&quot;Republic Day&quot;, &quot;Australia Day&quot;]</span>
<span class="hljs-comment">// }</span>

type = <span class="hljs-title function_">mapOf</span>(date, <span class="hljs-title function_">setOf</span>(string));
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(type.<span class="hljs-title function_">fromJSON</span>(holidays));
<span class="hljs-comment">// Map {</span>
<span class="hljs-comment">//   Sun Jan 01 2017 00:00:00 =&gt; Set {&quot;New Year&#x27;s Day&quot;, &quot;Public Domain Day&quot;},</span>
<span class="hljs-comment">//   Wed Jan 25 2017 00:00:00 =&gt; Set {&quot;Republic Day&quot;, &quot;Australia Day&quot;}</span>
<span class="hljs-comment">// }</span>
</code></pre><h4>Composite Types</h4>
<p>Okay, lets move on to composite types.  Composite types contain basic types and other composite types.  You could define a <code>fromJSON</code> and <code>toJSON</code> function for every composite type as well, but there is a much simpler solution.  Let&#39;s define a <strong>schema</strong> to be a JavaScript object whose values are all <strong>type mappers</strong>.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> commentSchema = {
    <span class="hljs-attr">author</span>: string,
    <span class="hljs-attr">content</span>: string,
    <span class="hljs-attr">likes</span>: number,
    <span class="hljs-attr">flagged</span>: boolean,
    <span class="hljs-attr">posted</span>: date
};
</code></pre><p>Then we can turn arbitrary <strong>schemas</strong> into <strong>type mappers</strong>:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> _ <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;lodash&#x27;</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">typeMapper</span>(<span class="hljs-params">schema</span>) {
    <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">fromJSON</span>: <span class="hljs-function"><span class="hljs-params">object</span> =&gt;</span> _.<span class="hljs-title function_">mapValues</span>(schema, <span class="hljs-function">(<span class="hljs-params">type, key</span>) =&gt;</span> type.<span class="hljs-title function_">fromJSON</span>(object[key])),
        <span class="hljs-attr">toJSON</span>:   <span class="hljs-function"><span class="hljs-params">object</span> =&gt;</span> _.<span class="hljs-title function_">mapValues</span>(schema, <span class="hljs-function">(<span class="hljs-params">type, key</span>) =&gt;</span> type.<span class="hljs-title function_">toJSON</span>(object[key]))
    };
}

<span class="hljs-keyword">const</span> commentType = <span class="hljs-title function_">typeMapper</span>(commentSchema);
</code></pre><p>And now we can plug this type into an appropriate location in our application code, for example:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">loadComment</span>(<span class="hljs-params">id</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">`/comments/<span class="hljs-subst">${id}</span>`</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> {
        <span class="hljs-keyword">const</span> jsonObject = response.<span class="hljs-title function_">json</span>();
        <span class="hljs-keyword">const</span> applicationObject = commentType.<span class="hljs-title function_">fromJSON</span>(jsonObject);
        <span class="hljs-keyword">return</span> applicationObject;
    });
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">createComment</span>(<span class="hljs-params">commentObject</span>) {
    <span class="hljs-keyword">const</span> jsonObject = commentType.<span class="hljs-title function_">toJSON</span>(commentObject);
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;/comments&#x27;</span>, {
        <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;POST&#x27;</span>,
        <span class="hljs-attr">body</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(jsonObject),
        <span class="hljs-attr">headers</span>: { <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span> }
    });
}
</code></pre><p>That composite type contained only basic types.  Let&#39;s look at one that also uses type constructors and other composite types:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> articleType = <span class="hljs-title function_">typeMapper</span>({
    <span class="hljs-attr">author</span>: string,
    <span class="hljs-attr">content</span>: string,
    <span class="hljs-attr">published</span>: boolean,
    <span class="hljs-attr">comments</span>: <span class="hljs-title function_">listOf</span>(commentType)
});

<span class="hljs-keyword">function</span> <span class="hljs-title function_">loadArticle</span>(<span class="hljs-params">id</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">`/articles/<span class="hljs-subst">${id}</span>`</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">r</span> =&gt;</span> articleType.<span class="hljs-title function_">fromJSON</span>(r.<span class="hljs-title function_">json</span>()));
}
</code></pre><h3>Up Next</h3>
<p>In part two of this series I&#39;ll show how we can:</p>
<ul>
<li>deserialize into ES6 classes</li>
<li>deserialize into Immutable collections and records</li>
<li>use the <code>reviver</code> and <code>replacer</code> arguments of <code>JSON.parse</code> and <code>JSON.stringify</code></li>
</ul>
<p>In part three, I&#39;ll look into how this works with TypeScript.  I imagine TypeScript developers make heavier use of application-defined types, so it could be even more useful in that context.  I haven&#39;t used TypeScript much before, but I think it should plug in pretty transparently.</p>
<p>By the end of this series, I&#39;d also like to publish this code on github and npm.  The main things are to decide what basic types and type constructors should be included in the package, and to write some unit tests and developer documentation.</p>
<p>If you have any feedback or advice, I&#39;d love to hear it!  You can get in touch on twitter at <a href="https://twitter.com/niallwingham">@niallwingham</a>.</p>
<section class="footnotes" data-footnotes>
<h2 id="footnote-label" class="sr-only">Footnotes</h2>
<ol>
<li id="footnote-prior-art">
<p>In fact, I still think I must have somehow overlooked an existing solution because this is a pretty general problem.  If you&#39;ve written or used one, please let me know. <a href="#footnote-ref-prior-art" data-footnote-backref aria-label="Back to reference prior-art">↩</a></p>
</li>
<li id="footnote-guesswork">
<p>For example, what if you deserialize comment data with a string content property, and a date posted property using a “date-aware” parser?  If a user enters a comment that happens to be a valid ISO string, both properties are going to end up parsed as dates. <a href="#footnote-ref-guesswork" data-footnote-backref aria-label="Back to reference guesswork">↩</a></p>
</li>
</ol>
</section>
</div><footer class="Post_post__meta__j55Gy">Posted on<!-- --> <time dateTime="2017-03-03" itemProp="datePublished">2017-03-03</time> <!-- -->by<!-- --> <span itemProp="author" itemscope="" itemType="http://schema.org/Person"><span itemProp="name">niall</span></span></footer></article></div></div></div></section></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"postData":{"id":"parsing-json-with-types-1","href":{"pathname":"/blog/[year]/[month]/[day]/[slug]","query":{"year":"2017","month":"03","day":"03","slug":"parsing-json-with-types-1"}},"contentHtml":"\u003cp\u003eI like to have well-defined models of my application data, especially at service boundaries.  I usually also define types in my application code to reflect these models.  When data are sent from a service, their values are serialized and their types are mapped onto the type system of the serialization format.  Then, when receiving data, I need to deserialize the values \u003cem\u003eand also\u003c/em\u003e map the types back into the richer type system of my application code.\u003c/p\u003e\n\u003cp\u003eIn statically typed languages, application frameworks or libraries typically handle this for me.  In dynamically typed languages, the situation is usually worse.  All a library has to go off is the runtime type of the deserialized values, which restricts it to types representable in the serialization format.  For JSON being deserialized into a JavaScript application, this means all I get are strings, numbers, booleans, and arrays or objects (i.e. string-keyed maps) of those basic types.\u003c/p\u003e\n\u003cp\u003eI want a systematic way to deserialize JSON data into my application types.\u003c/p\u003e\n\u003ch3\u003ePrior Art\u003c/h3\u003e\n\u003cp\u003eI thought there must exist a JavaScript package to do this already but I wasn’t able to find anything very promising.\u003csup\u003e\u003ca id=\"footnote-ref-prior-art\" href=\"#footnote-prior-art\" data-footnote-ref aria-describedby=\"footnote-label\"\u003e1\u003c/a\u003e\u003c/sup\u003e\u003c/p\u003e\n\u003cp\u003eSome work has been done on recognizing certain types, especially ISO date strings, and parsing them automatically into date objects.  See for example \u003ca href=\"https://weblog.west-wind.com/posts/2014/Jan/06/JavaScript-JSON-Date-Parsing-and-real-Dates\"\u003eJavaScript JSON Date Parsing and real Dates\u003c/a\u003e.  But this doesn’t let you use application-defined types, and it still involves a lot of guesswork.\u003csup\u003e\u003ca id=\"footnote-ref-guesswork\" href=\"#footnote-guesswork\" data-footnote-ref aria-describedby=\"footnote-label\"\u003e2\u003c/a\u003e\u003c/sup\u003e\u003c/p\u003e\n\u003cp\u003eThere are some more promising projects like \u003ca href=\"https://github.com/pd/typed-json\"\u003etyped-json\u003c/a\u003e which attempt to deal with types in general, but these still have significant limitations.  They require type information, like a constructor name, to be embedded in the data.  This couples your service code to the type system of one particular client, which is... not great.  And of course, if you don’t control the service you are receiving data from, this is impossible to implement.\u003c/p\u003e\n\u003ch3\u003eType Mapping\u003c/h3\u003e\n\u003cp\u003eWhat I really wanted was something that would (a) not require services to be aware of what my client was doing, and (b) give me powerful building blocks for mapping data into my application types.\u003c/p\u003e\n\u003cp\u003eFor clarity, let me define a few terms as they will be used in the remainder of this post before showing you what I made:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eJSON Object:\u003c/strong\u003e A JavaScript object whose values are exclusively JSON types.  This is the kind of object you get back from JSON.parse().\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eApplication Object:\u003c/strong\u003e A JavaScript object whose values may include JavaScript’s other built-in types (e.g. Date) and application-defined types (e.g. ES6 classes or objects with custom prototype chains).\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eDeserialization\u003c/strong\u003e: The process of turning a JSON object into an application object.  \u003cstrong\u003eSerialization\u003c/strong\u003e is the reverse.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eType Mapper:\u003c/strong\u003e A JavaScript object with \u003ccode\u003efromJSON\u003c/code\u003e and \u003ccode\u003etoJSON\u003c/code\u003e properties, which are functions that implement deserialization and serialization.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eNow, on to the code...\u003c/p\u003e\n\u003ch4\u003eBasic Types\u003c/h4\u003e\n\u003cp\u003eBasic types are the primitives of a type system.  Based on our definition above, let\u0026#39;s define a few type mappers for basic types:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-javascript\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e string = {\n    \u003cspan class=\"hljs-attr\"\u003efromJSON\u003c/span\u003e: \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003es\u003c/span\u003e =\u0026gt;\u003c/span\u003e s,\n    \u003cspan class=\"hljs-attr\"\u003etoJSON\u003c/span\u003e: \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003es\u003c/span\u003e =\u0026gt;\u003c/span\u003e s\n};\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e number = {\n    \u003cspan class=\"hljs-attr\"\u003efromJSON\u003c/span\u003e: \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003en\u003c/span\u003e =\u0026gt;\u003c/span\u003e n,\n    \u003cspan class=\"hljs-attr\"\u003etoJSON\u003c/span\u003e: \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003en\u003c/span\u003e =\u0026gt;\u003c/span\u003e n\n};\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e boolean = {\n    \u003cspan class=\"hljs-comment\"\u003e// Left as an exercise for the reader\u003c/span\u003e\n};\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eIt\u0026#39;s brilliant, right?  Well, these types are shared by JSON and JavaScript\u0026#39;s type systems, so there\u0026#39;s nothing to do.  Let\u0026#39;s try dates next:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-javascript\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e date = {\n    \u003cspan class=\"hljs-attr\"\u003efromJSON\u003c/span\u003e: \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eisoString\u003c/span\u003e =\u0026gt;\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eDate\u003c/span\u003e(isoString),\n    \u003cspan class=\"hljs-attr\"\u003etoJSON\u003c/span\u003e: \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003edate\u003c/span\u003e =\u0026gt;\u003c/span\u003e date.\u003cspan class=\"hljs-title function_\"\u003etoISOString\u003c/span\u003e()\n};\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eFantastic.  Of course, we could also represent dates in our application using \u003ca href=\"https://momentjs.com/\"\u003emoment\u003c/a\u003e and they could be represented in our JSON data as time values (number of milliseconds since Unix epoch).  Then, our date type mapper would look like:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-javascript\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e moment \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x27;moment\u0026#x27;\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e date = {\n    \u003cspan class=\"hljs-attr\"\u003efromJSON\u003c/span\u003e: \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003etimeValue\u003c/span\u003e =\u0026gt;\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emoment\u003c/span\u003e(timeValue),\n    \u003cspan class=\"hljs-attr\"\u003etoJSON\u003c/span\u003e: \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003em\u003c/span\u003e =\u0026gt;\u003c/span\u003e m.\u003cspan class=\"hljs-title function_\"\u003evalueOf\u003c/span\u003e()\n};\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eSo even basic type mappers can be redefined based on the needs of the application or the eccentricities of the services it connects to.\u003c/p\u003e\n\u003ch4\u003eParameterized Types\u003c/h4\u003e\n\u003cp\u003eIt doesn\u0026#39;t make sense to define all basic type mappers this way.  Some types may be parameterized, e.g. an array of numbers vs. an array of strings.  A \u003cstrong\u003etype mapper constructor\u003c/strong\u003e, which is a function that returns a type mapper, is a way to implement them.  Let\u0026#39;s define a few type mapper constructors:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003earrayOf\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003etype\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e {\n        \u003cspan class=\"hljs-attr\"\u003efromJSON\u003c/span\u003e: \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003earray\u003c/span\u003e =\u0026gt;\u003c/span\u003e array.\u003cspan class=\"hljs-title function_\"\u003emap\u003c/span\u003e(type.\u003cspan class=\"hljs-property\"\u003efromJSON\u003c/span\u003e),\n        \u003cspan class=\"hljs-attr\"\u003etoJSON\u003c/span\u003e:   \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003earray\u003c/span\u003e =\u0026gt;\u003c/span\u003e array.\u003cspan class=\"hljs-title function_\"\u003emap\u003c/span\u003e(type.\u003cspan class=\"hljs-property\"\u003etoJSON\u003c/span\u003e)\n    };\n}\n\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003esetOf\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003etype\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e {\n        \u003cspan class=\"hljs-attr\"\u003efromJSON\u003c/span\u003e: \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003earray\u003c/span\u003e =\u0026gt;\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eSet\u003c/span\u003e(array.\u003cspan class=\"hljs-title function_\"\u003emap\u003c/span\u003e(type.\u003cspan class=\"hljs-property\"\u003efromJSON\u003c/span\u003e)),\n        \u003cspan class=\"hljs-attr\"\u003etoJSON\u003c/span\u003e:   \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eset\u003c/span\u003e =\u0026gt;\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eArray\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003efrom\u003c/span\u003e(set, type.\u003cspan class=\"hljs-property\"\u003etoJSON\u003c/span\u003e),\n    };\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e fibonacci = [\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e];\n\n\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e type = \u003cspan class=\"hljs-title function_\"\u003earrayOf\u003c/span\u003e(number);\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(type.\u003cspan class=\"hljs-title function_\"\u003efromJSON\u003c/span\u003e(fibonacci));\n\u003cspan class=\"hljs-comment\"\u003e// [1, 1, 2, 3, 4]\u003c/span\u003e\n\ntype = \u003cspan class=\"hljs-title function_\"\u003esetOf\u003c/span\u003e(number);\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(type.\u003cspan class=\"hljs-title function_\"\u003efromJSON\u003c/span\u003e(fibonacci));\n\u003cspan class=\"hljs-comment\"\u003e// Set {1, 2, 3, 4}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNote that JavaScript arrays and sets have the same representation in JSON\u0026#39;s type system but we can choose how to deserialize it by specifying a type mapper.\u003c/p\u003e\n\u003cp\u003eMaps are another useful parameterized type to implement.  In JavaScript, we often use objects if all we need is a string-keyed map, but let\u0026#39;s also add the possibility of using actual Map objects which support keys of any type.  Again, both of these will be represented the same way in JSON\u0026#39;s type system.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eobjectOf\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003etype\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e {\n        \u003cspan class=\"hljs-attr\"\u003efromJSON\u003c/span\u003e: \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eobject\u003c/span\u003e =\u0026gt;\u003c/span\u003e _.\u003cspan class=\"hljs-title function_\"\u003emapValues\u003c/span\u003e(object, type.\u003cspan class=\"hljs-property\"\u003efromJSON\u003c/span\u003e),\n        \u003cspan class=\"hljs-attr\"\u003etoJSON\u003c/span\u003e:   \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eobject\u003c/span\u003e =\u0026gt;\u003c/span\u003e _.\u003cspan class=\"hljs-title function_\"\u003emapValues\u003c/span\u003e(object, type.\u003cspan class=\"hljs-property\"\u003etoJSON\u003c/span\u003e),\n    };\n}\n\n\u003cspan class=\"hljs-comment\"\u003e// Helper function to map over an array of [key, value] tuples\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emapEntries\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003emapKey, mapValue\u003c/span\u003e) =\u0026gt; \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eentries\u003c/span\u003e =\u0026gt;\u003c/span\u003e entries.\u003cspan class=\"hljs-title function_\"\u003emap\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003e[key, value]\u003c/span\u003e) =\u0026gt;\u003c/span\u003e [\u003cspan class=\"hljs-title function_\"\u003emapKey\u003c/span\u003e(key), \u003cspan class=\"hljs-title function_\"\u003emapValue\u003c/span\u003e(value)]);\n\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emapOf\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ekeyType, valueType\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e {\n        \u003cspan class=\"hljs-attr\"\u003efromJSON\u003c/span\u003e: \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eobject\u003c/span\u003e =\u0026gt;\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMap\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003emapEntries\u003c/span\u003e(keyType.\u003cspan class=\"hljs-property\"\u003efromJSON\u003c/span\u003e, valueType.\u003cspan class=\"hljs-property\"\u003efromJSON\u003c/span\u003e)(_.\u003cspan class=\"hljs-title function_\"\u003etoPairs\u003c/span\u003e(object))),\n        \u003cspan class=\"hljs-attr\"\u003etoJSON\u003c/span\u003e:   \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003emap\u003c/span\u003e =\u0026gt;\u003c/span\u003e _.\u003cspan class=\"hljs-title function_\"\u003efromPairs\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003emapEntries\u003c/span\u003e(keyType.\u003cspan class=\"hljs-property\"\u003etoJSON\u003c/span\u003e, valueType.\u003cspan class=\"hljs-property\"\u003etoJSON\u003c/span\u003e)(\u003cspan class=\"hljs-title class_\"\u003eArray\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003efrom\u003c/span\u003e(map)))\n    };\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e holidays = {\n    \u003cspan class=\"hljs-string\"\u003e\u0026quot;2017-01-01\u0026quot;\u003c/span\u003e: [\u003cspan class=\"hljs-string\"\u003e\u0026quot;New Year\u0026#x27;s Day\u0026quot;\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\u0026quot;Public Domain Day\u0026quot;\u003c/span\u003e],\n    \u003cspan class=\"hljs-string\"\u003e\u0026quot;2017-01-25\u0026quot;\u003c/span\u003e: [\u003cspan class=\"hljs-string\"\u003e\u0026quot;Republic Day\u0026quot;\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\u0026quot;Australia Day\u0026quot;\u003c/span\u003e]\n};\n\n\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e type = \u003cspan class=\"hljs-title function_\"\u003eobjectOf\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003earrayOf\u003c/span\u003e(string));\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(type.\u003cspan class=\"hljs-title function_\"\u003efromJSON\u003c/span\u003e(holidays));\n\u003cspan class=\"hljs-comment\"\u003e// Object {\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e//    2017-01-01: [\u0026quot;New Year\u0026#x27;s Day\u0026quot;, \u0026quot;Public Domain Day\u0026quot;],\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e//    2017-01-25: [\u0026quot;Republic Day\u0026quot;, \u0026quot;Australia Day\u0026quot;]\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// }\u003c/span\u003e\n\ntype = \u003cspan class=\"hljs-title function_\"\u003emapOf\u003c/span\u003e(date, \u003cspan class=\"hljs-title function_\"\u003esetOf\u003c/span\u003e(string));\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(type.\u003cspan class=\"hljs-title function_\"\u003efromJSON\u003c/span\u003e(holidays));\n\u003cspan class=\"hljs-comment\"\u003e// Map {\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e//   Sun Jan 01 2017 00:00:00 =\u0026gt; Set {\u0026quot;New Year\u0026#x27;s Day\u0026quot;, \u0026quot;Public Domain Day\u0026quot;},\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e//   Wed Jan 25 2017 00:00:00 =\u0026gt; Set {\u0026quot;Republic Day\u0026quot;, \u0026quot;Australia Day\u0026quot;}\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// }\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003ch4\u003eComposite Types\u003c/h4\u003e\n\u003cp\u003eOkay, lets move on to composite types.  Composite types contain basic types and other composite types.  You could define a \u003ccode\u003efromJSON\u003c/code\u003e and \u003ccode\u003etoJSON\u003c/code\u003e function for every composite type as well, but there is a much simpler solution.  Let\u0026#39;s define a \u003cstrong\u003eschema\u003c/strong\u003e to be a JavaScript object whose values are all \u003cstrong\u003etype mappers\u003c/strong\u003e.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e commentSchema = {\n    \u003cspan class=\"hljs-attr\"\u003eauthor\u003c/span\u003e: string,\n    \u003cspan class=\"hljs-attr\"\u003econtent\u003c/span\u003e: string,\n    \u003cspan class=\"hljs-attr\"\u003elikes\u003c/span\u003e: number,\n    \u003cspan class=\"hljs-attr\"\u003eflagged\u003c/span\u003e: boolean,\n    \u003cspan class=\"hljs-attr\"\u003eposted\u003c/span\u003e: date\n};\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThen we can turn arbitrary \u003cstrong\u003eschemas\u003c/strong\u003e into \u003cstrong\u003etype mappers\u003c/strong\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e _ \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x27;lodash\u0026#x27;\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003etypeMapper\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eschema\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e {\n        \u003cspan class=\"hljs-attr\"\u003efromJSON\u003c/span\u003e: \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eobject\u003c/span\u003e =\u0026gt;\u003c/span\u003e _.\u003cspan class=\"hljs-title function_\"\u003emapValues\u003c/span\u003e(schema, \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003etype, key\u003c/span\u003e) =\u0026gt;\u003c/span\u003e type.\u003cspan class=\"hljs-title function_\"\u003efromJSON\u003c/span\u003e(object[key])),\n        \u003cspan class=\"hljs-attr\"\u003etoJSON\u003c/span\u003e:   \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eobject\u003c/span\u003e =\u0026gt;\u003c/span\u003e _.\u003cspan class=\"hljs-title function_\"\u003emapValues\u003c/span\u003e(schema, \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003etype, key\u003c/span\u003e) =\u0026gt;\u003c/span\u003e type.\u003cspan class=\"hljs-title function_\"\u003etoJSON\u003c/span\u003e(object[key]))\n    };\n}\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e commentType = \u003cspan class=\"hljs-title function_\"\u003etypeMapper\u003c/span\u003e(commentSchema);\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAnd now we can plug this type into an appropriate location in our application code, for example:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eloadComment\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eid\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efetch\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`/comments/\u003cspan class=\"hljs-subst\"\u003e${id}\u003c/span\u003e`\u003c/span\u003e).\u003cspan class=\"hljs-title function_\"\u003ethen\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eresponse\u003c/span\u003e =\u0026gt;\u003c/span\u003e {\n        \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e jsonObject = response.\u003cspan class=\"hljs-title function_\"\u003ejson\u003c/span\u003e();\n        \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e applicationObject = commentType.\u003cspan class=\"hljs-title function_\"\u003efromJSON\u003c/span\u003e(jsonObject);\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e applicationObject;\n    });\n}\n\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ecreateComment\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ecommentObject\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e jsonObject = commentType.\u003cspan class=\"hljs-title function_\"\u003etoJSON\u003c/span\u003e(commentObject);\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efetch\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;/comments\u0026#x27;\u003c/span\u003e, {\n        \u003cspan class=\"hljs-attr\"\u003emethod\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\u0026#x27;POST\u0026#x27;\u003c/span\u003e,\n        \u003cspan class=\"hljs-attr\"\u003ebody\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eJSON\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003estringify\u003c/span\u003e(jsonObject),\n        \u003cspan class=\"hljs-attr\"\u003eheaders\u003c/span\u003e: { \u003cspan class=\"hljs-string\"\u003e\u0026#x27;Content-Type\u0026#x27;\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\u0026#x27;application/json\u0026#x27;\u003c/span\u003e }\n    });\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThat composite type contained only basic types.  Let\u0026#39;s look at one that also uses type constructors and other composite types:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e articleType = \u003cspan class=\"hljs-title function_\"\u003etypeMapper\u003c/span\u003e({\n    \u003cspan class=\"hljs-attr\"\u003eauthor\u003c/span\u003e: string,\n    \u003cspan class=\"hljs-attr\"\u003econtent\u003c/span\u003e: string,\n    \u003cspan class=\"hljs-attr\"\u003epublished\u003c/span\u003e: boolean,\n    \u003cspan class=\"hljs-attr\"\u003ecomments\u003c/span\u003e: \u003cspan class=\"hljs-title function_\"\u003elistOf\u003c/span\u003e(commentType)\n});\n\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eloadArticle\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eid\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efetch\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`/articles/\u003cspan class=\"hljs-subst\"\u003e${id}\u003c/span\u003e`\u003c/span\u003e).\u003cspan class=\"hljs-title function_\"\u003ethen\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003er\u003c/span\u003e =\u0026gt;\u003c/span\u003e articleType.\u003cspan class=\"hljs-title function_\"\u003efromJSON\u003c/span\u003e(r.\u003cspan class=\"hljs-title function_\"\u003ejson\u003c/span\u003e()));\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch3\u003eUp Next\u003c/h3\u003e\n\u003cp\u003eIn part two of this series I\u0026#39;ll show how we can:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003edeserialize into ES6 classes\u003c/li\u003e\n\u003cli\u003edeserialize into Immutable collections and records\u003c/li\u003e\n\u003cli\u003euse the \u003ccode\u003ereviver\u003c/code\u003e and \u003ccode\u003ereplacer\u003c/code\u003e arguments of \u003ccode\u003eJSON.parse\u003c/code\u003e and \u003ccode\u003eJSON.stringify\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIn part three, I\u0026#39;ll look into how this works with TypeScript.  I imagine TypeScript developers make heavier use of application-defined types, so it could be even more useful in that context.  I haven\u0026#39;t used TypeScript much before, but I think it should plug in pretty transparently.\u003c/p\u003e\n\u003cp\u003eBy the end of this series, I\u0026#39;d also like to publish this code on github and npm.  The main things are to decide what basic types and type constructors should be included in the package, and to write some unit tests and developer documentation.\u003c/p\u003e\n\u003cp\u003eIf you have any feedback or advice, I\u0026#39;d love to hear it!  You can get in touch on twitter at \u003ca href=\"https://twitter.com/niallwingham\"\u003e@niallwingham\u003c/a\u003e.\u003c/p\u003e\n\u003csection class=\"footnotes\" data-footnotes\u003e\n\u003ch2 id=\"footnote-label\" class=\"sr-only\"\u003eFootnotes\u003c/h2\u003e\n\u003col\u003e\n\u003cli id=\"footnote-prior-art\"\u003e\n\u003cp\u003eIn fact, I still think I must have somehow overlooked an existing solution because this is a pretty general problem.  If you\u0026#39;ve written or used one, please let me know. \u003ca href=\"#footnote-ref-prior-art\" data-footnote-backref aria-label=\"Back to reference prior-art\"\u003e↩\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli id=\"footnote-guesswork\"\u003e\n\u003cp\u003eFor example, what if you deserialize comment data with a string content property, and a date posted property using a “date-aware” parser?  If a user enters a comment that happens to be a valid ISO string, both properties are going to end up parsed as dates. \u003ca href=\"#footnote-ref-guesswork\" data-footnote-backref aria-label=\"Back to reference guesswork\"\u003e↩\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/section\u003e\n","layout":"post","author":"niall","title":"Parsing JSON with Types (Part 1)","image":"/img/posts/minified.jpg","credit":"Markus Spiske","date":"2017-03-03","excerpt":"\u003cp\u003eI like to have well-defined models of my application data, especially at service boundaries.  I usually also define types in my application code to reflect these models.  When data are sent from a service, their values are serialized and their types are mapped onto the type system of the serialization format.  Then, when receiving data, I need to deserialize the values \u003cem\u003eand also\u003c/em\u003e map the types back into the richer type system of my application code.\u003c/p\u003e\n\u003cp\u003eIn statically typed languages, application frameworks or libraries typically handle this for me\u003c/p\u003e\n"}},"__N_SSG":true},"page":"/blog/[year]/[month]/[day]/[slug]","query":{"year":"2017","month":"03","day":"03","slug":"parsing-json-with-types-1"},"buildId":"W4pufNDEt06x3-24viEGe","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>
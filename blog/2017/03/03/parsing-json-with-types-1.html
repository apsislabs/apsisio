<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0">
    <title>Apsis Labs | Parsing JSON with Types (Part 1)</title>
    <!-- !START meta -->
    <meta name="description" content="I like to have well-defined models of my application data, especially at service boundaries.  I usually also define types in my application code to reflect t...">
    <link rel="canonical" href="/blog/2017/03/03/parsing-json-with-types-1">
    <link rel="alternate" type="application/rss+xml" title="Development Chop Shop" href="/feed.xml">
    <meta content="Apsis Labs" property="og:site_name">
    <meta content="Parsing JSON with Types (Part 1)" property="og:title">
    <meta content="article" property="og:type">
    <meta content="I like to have well-defined models of my application data, especially at service boundaries.  I usually also define types in my application code to reflect t..." property="og:description">
    <meta content="/blog/2017/03/03/parsing-json-with-types-1" property="og:url">
    <meta content="2017-03-03T00:00:00+00:00" property="article:published_time">
    <meta content="/assets/posts/minified.jpg" property="og:image">
    <!-- !END meta -->
    <!-- !START favicons -->
    <link rel="apple-touch-icon" sizes="57x57" href="/assets/favicons/apple-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="60x60" href="/assets/favicons/apple-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/assets/favicons/apple-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="/assets/favicons/apple-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/assets/favicons/apple-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="/assets/favicons/apple-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="/assets/favicons/apple-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/assets/favicons/apple-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/assets/favicons/apple-icon-180x180.png">
    <link rel="icon" type="image/png" sizes="192x192"  href="/assets/favicons/android-icon-192x192.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png">
    <link rel="icon" type="image/png" href="/assets/favicons/favicon.ico">
    <!-- !END favicons -->
    <!-- !START polyfill -->
    <!--[if lt IE 9]>
      <script type="text/javascript" src="/assets/vendor/html5shiv.min.js"></script>
      <script type="text/javascript" src="/assets/vendor/html5shiv-printshiv.min.js"></script>
    <![endif]-->
    <script type="text/javascript" src="/assets/polyfill.js" async="async"></script>
    <!-- !END polyfill -->
    <!-- !START styles -->
    <link type="text/css" rel="stylesheet" href="/assets/app.css">
    <!-- !END styles -->
  </head>
  <body class="">
    <!-- !START navbar -->
    <header id="navbar" class="navbar ">
      <div class="navbar__header">
        <a href="/" class="logo logo--navbar logo--mobile navbar__logo">
          <picture>
            <source media="(min-width: 960px)" srcset="/assets/logos/apsis_blue.png" />
            <source srcset="/assets/logos/apsis_mobile_blue.png" />
            <img src="/assets/logos/apsis_blue.png" alt="Apsis Labs" class="logo__image">
          </picture>
          <h1 class="logo__text">Apsis Labs</h1>
        </a>
        <button id="nav-toggle" class="navbar__nav-toggle">
          <span class="navicon ">
            <span class="navicon__bar"></span>
          </span>
          <span class="sr">Toggle Menu</span>
        </button>
      </div>
      <nav class="navbar__nav">
        <a class="navbar__nav-link" href="/#services">Services</a>
        <a class="navbar__nav-link" href="/#about">About</a>
        <a class="navbar__nav-link" href="/#clients">Clients</a>
        <a class="navbar__nav-link" href="/#contact">Contact</a>
        <a class="navbar__nav-link" href="/jobs/">Jobs</a>
        <a class="navbar__nav-link" href="/blog/">Blog</a>
      </nav>
    </header>
    <!-- !END navbar -->
    <!-- !START content -->
    <div id="content">
      <!-- !START schema.org -->
      <script type="application/ld+json">
        {
            "@context": "http://schema.org",
            "@type": "BlogPosting",
            "headline": "Parsing JSON with Types (Part 1)",
            "datePublished": "2017-03-03 00:00:00 +0000",
            "dateModified": "2017-03-03 00:00:00 +0000",
            "author": {
              "@type": "Person",
              "name": "Niall Wingham"
            },
            "publisher": {
              "@type": "Organization",
              "name": "Apsis Labs",
              "logo": "/assets/logos/apsis_blue.png"
            },
            "mainEntityOfPage": {
              "@type": "WebPage",
              "@id": "/blog/2017/03/03/parsing-json-with-types-1"
            },
        
              "image": ["/assets/posts/minified.jpg"]
        
          }
      </script>
      <!-- !END schema.org -->
      <div class="post-wrapper post-wrapper--single">
        <div class="container">
          <article class="post">
            <header class="post__header">
              <div class="post__image-wrapper">
                <img src="/assets/posts/minified.jpg" alt="Parsing JSON with Types (Part 1). Photo by Markus Spiske." class="post__image" data-action="zoom">
              </div>
              <small class="post__photo-credit">Image by Markus Spiske</small>
              <h2 class="post__title" itemprop="name headline">
                <a href="">
                  Parsing JSON with Types (Part 1)
        </a>
              </h2>
            </header>
            <div class="post__content">
              <p>I like to have well-defined models of my application data, especially at service boundaries.  I usually also define types in my application code to reflect these models.  When data are sent from a service, their values are serialized and their types are mapped onto the type system of the serialization format.  Then, when receiving data, I need to deserialize the values <em>and also</em> map the types back into the richer type system of my application code.</p>
              <p>In statically typed languages, application frameworks or libraries typically handle this for me.  In dynamically typed languages, the situation is usually worse.  All a library has to go off is the runtime type of the deserialized values, which restricts it to types representable in the serialization format.  For JSON being deserialized into a JavaScript application, this means all I get are strings, numbers, booleans, and arrays or objects (i.e. string-keyed maps) of those basic types.</p>
              <p>I want a systematic way to deserialize JSON data into my application types.</p>
              <h3>Prior Art</h3>
              <p>I thought there must exist a JavaScript package to do this already but I wasn’t able to find anything very promising.<sup id="fnref1"><a href="#fn1" rel="footnote">1</a></sup></p>
              <p>Some work has been done on recognizing certain types, especially ISO date strings, and parsing them automatically into date objects.  See for example <a href="https://weblog.west-wind.com/posts/2014/Jan/06/JavaScript-JSON-Date-Parsing-and-real-Dates">JavaScript JSON Date Parsing and real Dates</a>.  But this doesn’t let you use application-defined types, and it still involves a lot of guesswork.<sup id="fnref2"><a href="#fn2" rel="footnote">2</a></sup></p>
              <p>There are some more promising projects like <a href="https://github.com/pd/typed-json">typed-json</a> which attempt to deal with types in general, but these still have significant limitations.  They require type information, like a constructor name, to be embedded in the data.  This couples your service code to the type system of one particular client, which is&hellip; not great.  And of course, if you don’t control the service you are receiving data from, this is impossible to implement.</p>
              <h3>Type Mapping</h3>
              <p>What I really wanted was something that would (a) not require services to be aware of what my client was doing, and (b) give me powerful building blocks for mapping data into my application types.</p>
              <p>For clarity, let me define a few terms as they will be used in the remainder of this post before showing you what I made:</p>
              <ul>
                <li><strong>JSON Object:</strong> A JavaScript object whose values are exclusively JSON types.  This is the kind of object you get back from JSON.parse().</li>
                <li><strong>Application Object:</strong> A JavaScript object whose values may include JavaScript’s other built-in types (e.g. Date) and application-defined types (e.g. ES6 classes or objects with custom prototype chains).</li>
                <li><strong>Deserialization</strong>: The process of turning a JSON object into an application object.  <strong>Serialization</strong> is the reverse.</li>
                <li><strong>Type Mapper:</strong> A JavaScript object with <code>fromJSON</code> and <code>toJSON</code> properties, which are functions that implement deserialization and serialization.</li>
              </ul>
              <p>Now, on to the code&hellip;</p>
              <h4>Basic Types</h4>
              <p>Basic types are the primitives of a type system.  Based on our definition above, let&rsquo;s define a few type mappers for basic types:</p>
              <div class="highlight">
                <pre><code class="language-" data-lang="">const string = {
    fromJSON: s =&gt; s,
    toJSON: s =&gt; s
};

const number = {
    fromJSON: n =&gt; n,
    toJSON: n =&gt; n
};

const boolean = {
    // Left as an exercise for the reader
};
</code></pre>
              </div>
              <p>It&rsquo;s brilliant, right?  Well, these types are shared by JSON and JavaScript&rsquo;s type systems, so there&rsquo;s nothing to do.  Let&rsquo;s try dates next:</p>
              <div class="highlight">
                <pre><code class="language-" data-lang="">const date = {
    fromJSON: isoString =&gt; new Date(isoString),
    toJSON: date =&gt; date.toISOString()
};
</code></pre>
              </div>
              <p>Fantastic.  Of course, we could also represent dates in our application using <a href="https://momentjs.com/">moment</a> and they could be represented in our JSON data as time values (number of milliseconds since Unix epoch).  Then, our date type mapper would look like:</p>
              <div class="highlight">
                <pre><code class="language-" data-lang="">import moment from 'moment';

const date = {
    fromJSON: timeValue =&gt; moment(timeValue),
    toJSON: m =&gt; m.valueOf()
};
</code></pre>
              </div>
              <p>So even basic type mappers can be redefined based on the needs of the application or the eccentricities of the services it connects to.</p>
              <h4>Parameterized Types</h4>
              <p>It doesn&rsquo;t make sense to define all basic type mappers this way.  Some types may be parameterized, e.g. an array of numbers vs. an array of strings.  A <strong>type mapper constructor</strong>, which is a function that returns a type mapper, is a way to implement them.  Let&rsquo;s define a few type mapper constructors:</p>
              <div class="highlight">
                <pre><code class="language-" data-lang="">function arrayOf(type) {
    return {
        fromJSON: array =&gt; array.map(type.fromJSON),
        toJSON:   array =&gt; array.map(type.toJSON)
    };
}

function setOf(type) {
    return {
        fromJSON: array =&gt; new Set(array.map(type.fromJSON)),
        toJSON:   set =&gt; Array.from(set, type.toJSON),
    };
}
</code></pre>
              </div>
              <div class="highlight">
                <pre><code class="language-" data-lang="">const fibonacci = [1, 1, 2, 3, 5];

let type = arrayOf(number);
console.log(type.fromJSON(fibonacci));
// [1, 1, 2, 3, 4]

type = setOf(number);
console.log(type.fromJSON(fibonacci));
// Set {1, 2, 3, 4}
</code></pre>
              </div>
              <p>Note that JavaScript arrays and sets have the same representation in JSON&rsquo;s type system but we can choose how to deserialize it by specifying a type mapper.</p>
              <p>Maps are another useful parameterized type to implement.  In JavaScript, we often use objects if all we need is a string-keyed map, but let&rsquo;s also add the possibility of using actual Map objects which support keys of any type.  Again, both of these will be represented the same way in JSON&rsquo;s type system.</p>
              <div class="highlight">
                <pre><code class="language-" data-lang="">function objectOf(type) {
    return {
        fromJSON: object =&gt; _.mapValues(object, type.fromJSON),
        toJSON:   object =&gt; _.mapValues(object, type.toJSON),
    };
}

// Helper function to map over an array of [key, value] tuples
const mapEntries = (mapKey, mapValue) =&gt; entries =&gt; entries.map(([key, value]) =&gt; [mapKey(key), mapValue(value)]);

function mapOf(keyType, valueType) {
    return {
        fromJSON: object =&gt; new Map(mapEntries(keyType.fromJSON, valueType.fromJSON)(_.toPairs(object))),
        toJSON:   map =&gt; _.fromPairs(mapEntries(keyType.toJSON, valueType.toJSON)(Array.from(map)))
    };
}
</code></pre>
              </div>
              <div class="highlight">
                <pre><code class="language-" data-lang="">const holidays = {
    "2017-01-01": ["New Year's Day", "Public Domain Day"],
    "2017-01-25": ["Republic Day", "Australia Day"]
};

let type = objectOf(arrayOf(string));
console.log(type.fromJSON(holidays));
// Object {
//    2017-01-01: ["New Year's Day", "Public Domain Day"],
//    2017-01-25: ["Republic Day", "Australia Day"]
// }

type = mapOf(date, setOf(string));
console.log(type.fromJSON(holidays));
// Map {
//   Sun Jan 01 2017 00:00:00 =&gt; Set {"New Year's Day", "Public Domain Day"},
//   Wed Jan 25 2017 00:00:00 =&gt; Set {"Republic Day", "Australia Day"}
// }
</code></pre>
              </div>
              <h4>Composite Types</h4>
              <p>Okay, lets move on to composite types.  Composite types contain basic types and other composite types.  You could define a <code>fromJSON</code> and <code>toJSON</code> function for every composite type as well, but there is a much simpler solution.  Let&rsquo;s define a <strong>schema</strong> to be a JavaScript object whose values are all <strong>type mappers</strong>.</p>
              <div class="highlight">
                <pre><code class="language-" data-lang="">const commentSchema = {
    author: string,
    content: string,
    likes: number,
    flagged: boolean,
    posted: date
};
</code></pre>
              </div>
              <p>Then we can turn arbitrary <strong>schemas</strong> into <strong>type mappers</strong>:</p>
              <div class="highlight">
                <pre><code class="language-" data-lang="">import _ from 'lodash';

function typeMapper(schema) {
    return {
        fromJSON: object =&gt; _.mapValues(schema, (type, key) =&gt; type.fromJSON(object[key])),
        toJSON:   object =&gt; _.mapValues(schema, (type, key) =&gt; type.toJSON(object[key]))
    };
}

const commentType = typeMapper(commentSchema);
</code></pre>
              </div>
              <p>And now we can plug this type into an appropriate location in our application code, for example:</p>
              <div class="highlight">
                <pre><code class="language-" data-lang="">function loadComment(id) {
    return fetch(`/comments/${id}`).then(response =&gt; {
        const jsonObject = response.json();
        const applicationObject = commentType.fromJSON(jsonObject);
        return applicationObject;
    });
}

function createComment(commentObject) {
    const jsonObject = commentType.toJSON(commentObject);
    return fetch('/comments', {
        method: 'POST',
        body: JSON.stringify(jsonObject),
        headers: { 'Content-Type': 'application/json' }
    });
}
</code></pre>
              </div>
              <p>That composite type contained only basic types.  Let&rsquo;s look at one that also uses type constructors and other composite types:</p>
              <div class="highlight">
                <pre><code class="language-" data-lang="">const articleType = typeMapper({
    author: string,
    content: string,
    published: boolean,
    comments: listOf(commentType)
});

function loadArticle(id) {
    return fetch(`/articles/${id}`).then(r =&gt; articleType.fromJSON(r.json()));
}
</code></pre>
              </div>
              <h3>Up Next</h3>
              <p>In part two of this series I&rsquo;ll show how we can:</p>
              <ul>
                <li>deserialize into ES6 classes</li>
                <li>deserialize into Immutable collections and records</li>
                <li>use the <code>reviver</code> and <code>replacer</code> arguments of <code>JSON.parse</code> and <code>JSON.stringify</code></li>
              </ul>
              <p>In part three, I&rsquo;ll look into how this works with TypeScript.  I imagine TypeScript developers make heavier use of application-defined types, so it could be even more useful in that context.  I haven&rsquo;t used TypeScript much before, but I think it should plug in pretty transparently.</p>
              <p>By the end of this series, I&rsquo;d also like to publish this code on github and npm.  The main things are to decide what basic types and type constructors should be included in the package, and to write some unit tests and developer documentation.</p>
              <p>If you have any feedback or advice, I&rsquo;d love to hear it!  You can get in touch on twitter at <a href="https://twitter.com/niallwingham">@niallwingham</a>.</p>
              <div class="footnotes">
                <hr>
                <ol>
                  <li id="fn1">
                    <p>In fact, I still think I must have somehow overlooked an existing solution because this is a pretty general problem.  If you&rsquo;ve written or used one, please let me know.&nbsp;<a href="#fnref1" rev="footnote">&#8617;</a></p>
                  </li>
                  <li id="fn2">
                    <p>For example, what if you deserialize comment data with a string content property, and a date posted property using a “date-aware” parser?  If a user enters a comment that happens to be a valid ISO string, both properties are going to end up parsed as dates.&nbsp;<a href="#fnref2" rev="footnote">&#8617;</a></p>
                  </li>
                </ol>
              </div>
            </div>
            <aside class="author-block">
              <img src="/assets/people/niall.jpg" alt="Niall Wingham" class="author-block__image">
              <header class="author-block__header">
                <h5 class="author-block__title">Niall Wingham</h5>
              </header>
              <div class="author-block__content">
                <p>Niall is a cheerful curmudgeon and likes reading language and protocol specifications. He lives with his professorial wife and pint-sized daughter in Toronto, and is by default the head of the Canadian branch of Apsis. When he grows up he wants to be a farmer, or maybe a ballet dancer, or no, wait, a sailor!</p>
              </div>
            </aside>
          </article>
        </div>
      </div>
    </div>
    <!-- !END content -->
    <!-- !START footer -->
    <footer id="footer" class="site-footer">
      <div class="container">
        <small>
          &copy; 2021 apsis labs
            |
            shuttle image credit NASA
        </small>
      </div>
    </footer>
    <!-- !END footer -->
    <!-- !START javascript includes -->
    <script type="text/javascript" src="/assets/vendor.js"></script>
    <script type="text/javascript" src="/assets/scripts.js"></script>
    <!-- !END javascript includes -->
    <!-- !START Google Analytics -->
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
                  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
      
                  ga('create', 'UA-47858702-1', 'auto');
                  ga('send', 'pageview');
    </script>
    <!-- !END Google Analytics -->
    <!-- !START google fonts -->
    <script type="text/javascript">
      WebFontConfig = {
              google: { families: [ 'Open+Sans:400,300,300italic,400italic,600,700,600italic,700italic:latin', 'Source+Code+Pro:400,500,600,700:latin', 'Lora:400,400italic,700,700italic:latin' ] }
          };
      
          (function() {
              var wf = document.createElement('script');
              wf.src = 'https://ajax.googleapis.com/ajax/libs/webfont/1/webfont.js';
              wf.type = 'text/javascript';
              wf.async = 'true';
              var s = document.getElementsByTagName('script')[0];
              s.parentNode.insertBefore(wf, s);
          })();
    </script>
    <!-- !END google fonts -->
  </body>
</html>